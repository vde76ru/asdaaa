#!/usr/bin/env python3
"""
–ü–û–õ–ù–û–¶–ï–ù–ù–´–ô –ú–ï–ù–ï–î–ñ–ï–† –¢–û–†–ì–û–í–û–ì–û –ë–û–¢–ê –î–õ–Ø –ú–ù–û–ñ–ï–°–¢–í–ï–ù–ù–´–• –í–ê–õ–Æ–¢
===========================================================

‚ö†Ô∏è –í–ê–ñ–ù–û: –≠—Ç–æ—Ç —Ñ–∞–π–ª –ü–û–õ–ù–û–°–¢–¨–Æ –ó–ê–ú–ï–ù–Ø–ï–¢ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π src/bot/manager.py

–ü–û–õ–ù–ê–Ø –í–ï–†–°–ò–Ø —Å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–º —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–æ–º –∏ ML –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π (2200+ —Å—Ç—Ä–æ–∫):
‚úÖ –ê–≤—Ç–æ–ø–æ–∏—Å–∫ –∏ –∞–Ω–∞–ª–∏–∑ –¥–æ 200 —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä
‚úÖ 7+ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π —Å –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–º –≤—ã–±–æ—Ä–æ–º  
‚úÖ –ü–æ–ª–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–∏—Å–∫–∞–º–∏
‚úÖ –ú–∞—à–∏–Ω–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ –∏ –ø—Ä–µ–¥–∏–∫—Ç–∏–≤–Ω–∞—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∞
‚úÖ –ê–Ω–∞–ª–∏–∑ –Ω–æ–≤–æ—Å—Ç–µ–π –∏ —Å–æ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å–µ—Ç–µ–π
‚úÖ –°–∏—Å—Ç–µ–º–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∑–¥–æ—Ä–æ–≤—å—è
‚úÖ –ë—ç–∫—Ç–µ—Å—Ç–∏–Ω–≥ –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è
‚úÖ –≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö –∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∞
‚úÖ 10+ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö —Ü–∏–∫–ª–æ–≤ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
‚úÖ –ü–æ–ª–Ω–∞—è –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è —Ç–æ—Ä–≥–æ–≤–ª–∏

–ü—É—Ç—å: src/bot/manager.py
"""

import asyncio
import logging
import json
import pickle
import numpy as np
import pandas as pd
import psutil
import traceback
import signal
import threading
import time
from sqlalchemy import text
from typing import Dict, List, Optional, Tuple, Any, Set, Union, Callable
from datetime import datetime, timedelta
from dataclasses import dataclass, field, asdict
from enum import Enum
from collections import defaultdict, deque
from contextlib import asynccontextmanager
from pathlib import Path
import aiofiles
import aiohttp
from concurrent.futures import ThreadPoolExecutor
import warnings
warnings.filterwarnings('ignore')

# –ò–º–ø–æ—Ä—Ç—ã –ø—Ä–æ–µ–∫—Ç–∞
from ..core.unified_config import unified_config as config
from ..core.database import SessionLocal, get_session
from ..core.models import (
    Trade, TradingPair, Signal, TradeStatus, OrderSide, OrderType,
    BotState, StrategyPerformance, Candle, Balance, 
    MLModel, MLPrediction, NewsAnalysis, SocialSignal, TradingLog
)

# –ü–æ–¥–∞–≤–ª—è–µ–º TensorFlow warnings
import os
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'


logger = logging.getLogger(__name__)


# –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–ò
logger.info("="*60)
logger.info("üîç –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê –†–ï–ñ–ò–ú–û–í –¢–û–†–ì–û–í–õ–ò:")
logger.info(f"   PAPER_TRADING = {config.PAPER_TRADING}")
logger.info(f"   LIVE_TRADING = {config.LIVE_TRADING}")
logger.info(f"   TESTNET = {config.TESTNET}")
logger.info(f"   ENVIRONMENT = {config.ENVIRONMENT}")
logger.info("="*60)

# =================================================================
# ENUMS –ò DATACLASSES
# =================================================================

class BotStatus(Enum):
    """–°—Ç–∞—Ç—É—Å—ã –±–æ—Ç–∞"""
    STOPPED = "stopped"
    STARTING = "starting"
    RUNNING = "running"
    STOPPING = "stopping"
    ERROR = "error"
    PAUSED = "paused"
    EMERGENCY_STOP = "emergency_stop"

class ComponentStatus(Enum):
    """–°—Ç–∞—Ç—É—Å—ã –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤"""
    NOT_INITIALIZED = "not_initialized"
    INITIALIZING = "initializing" 
    READY = "ready"
    FAILED = "failed"
    DISABLED = "disabled"
    RECONNECTING = "reconnecting"

class MarketPhase(Enum):
    """–§–∞–∑—ã —Ä—ã–Ω–∫–∞"""
    ACCUMULATION = "accumulation"    # –ù–∞–∫–æ–ø–ª–µ–Ω–∏–µ
    MARKUP = "markup"                # –†–æ—Å—Ç
    DISTRIBUTION = "distribution"    # –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ  
    MARKDOWN = "markdown"            # –ü–∞–¥–µ–Ω–∏–µ
    UNKNOWN = "unknown"              # –ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–∞—è

class RiskLevel(Enum):
    """–£—Ä–æ–≤–Ω–∏ —Ä–∏—Å–∫–∞"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    EXTREME = "extreme"

class TradeDecision(Enum):
    """–†–µ—à–µ–Ω–∏—è –ø–æ —Å–¥–µ–ª–∫–∞–º"""
    STRONG_BUY = "strong_buy"
    BUY = "buy"
    WEAK_BUY = "weak_buy"
    HOLD = "hold"
    WEAK_SELL = "weak_sell"
    SELL = "sell"
    STRONG_SELL = "strong_sell"

@dataclass
class TradingOpportunity:
    """–†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è —Ç–æ—Ä–≥–æ–≤–∞—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å"""
    symbol: str
    strategy: str
    decision: TradeDecision
    confidence: float               # –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å 0-1
    expected_profit: float          # –û–∂–∏–¥–∞–µ–º–∞—è –ø—Ä–∏–±—ã–ª—å %
    expected_loss: float           # –û–∂–∏–¥–∞–µ–º—ã–π —É–±—ã—Ç–æ–∫ %
    risk_level: RiskLevel
    price: float                   # –¶–µ–Ω–∞ –≤—Ö–æ–¥–∞
    stop_loss: float              # –°—Ç–æ–ø-–ª–æ—Å—Å
    take_profit: float            # –¢–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç
    market_phase: MarketPhase
    volume_score: float           # –°–∫–æ—Ä –æ–±—ä–µ–º–∞ 0-1
    technical_score: float        # –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ 0-1
    ml_score: float              # ML –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ 0-1
    news_sentiment: float        # –ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–µ–π -1 to 1
    social_sentiment: float      # –°–æ—Ü–∏–∞–ª—å–Ω–æ–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ -1 to 1
    risk_reward_ratio: float     # –°–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Ä–∏—Å–∫/–¥–æ—Ö–æ–¥–Ω–æ—Å—Ç—å
    correlation_risk: float      # –†–∏—Å–∫ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–∏ 0-1
    volatility: float           # –í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å
    liquidity_score: float      # –õ–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å 0-1
    timeframe: str              # –¢–∞–π–º—Ñ—Ä–µ–π–º –∞–Ω–∞–ª–∏–∑–∞
    entry_reasons: List[str]    # –ü—Ä–∏—á–∏–Ω—ã –≤—Ö–æ–¥–∞
    exit_conditions: List[str]  # –£—Å–ª–æ–≤–∏—è –≤—ã—Ö–æ–¥–∞
    metadata: Dict[str, Any]    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    timestamp: datetime = field(default_factory=datetime.utcnow)
    expires_at: datetime = field(default_factory=lambda: datetime.utcnow() + timedelta(hours=1))

@dataclass
class MarketState:
    """–†–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Ä—ã–Ω–∫–∞"""
    overall_trend: str              # BULLISH, BEARISH, SIDEWAYS
    volatility: str                 # LOW, MEDIUM, HIGH, EXTREME
    fear_greed_index: int          # 0-100
    market_cap: float              # –û–±—â–∞—è –∫–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏—è
    volume_24h: float              # –û–±—ä–µ–º –∑–∞ 24—á
    dominance_btc: float           # –î–æ–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ BTC
    dominance_eth: float           # –î–æ–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ ETH
    active_pairs_count: int        # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–∞—Ä
    trending_pairs: List[str]      # –¢—Ä–µ–Ω–¥–æ–≤—ã–µ –ø–∞—Ä—ã
    declining_pairs: List[str]     # –ü–∞–¥–∞—é—â–∏–µ –ø–∞—Ä—ã
    correlation_matrix: Dict[str, Dict[str, float]]  # –ú–∞—Ç—Ä–∏—Ü–∞ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–π
    sector_performance: Dict[str, float]  # –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å–µ–∫—Ç–æ—Ä–æ–≤
    market_regime: str             # BULL_MARKET, BEAR_MARKET, SIDEWAYS_MARKET
    risk_level: RiskLevel         # –û–±—â–∏–π —É—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞
    timestamp: datetime = field(default_factory=datetime.utcnow)

@dataclass
class ComponentInfo:
    """–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–µ —Å–∏—Å—Ç–µ–º—ã"""
    name: str
    status: ComponentStatus
    instance: Any = None
    error: Optional[str] = None
    last_heartbeat: Optional[datetime] = None
    restart_count: int = 0
    dependencies: List[str] = field(default_factory=list)
    is_critical: bool = False
    health_check_interval: int = 60
    max_restart_attempts: int = 3

@dataclass
class PerformanceMetrics:
    """–ú–µ—Ç—Ä–∏–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏"""
    analysis_time_avg: float = 0.0
    trade_execution_time_avg: float = 0.0
    pairs_per_second: float = 0.0
    memory_usage_mb: float = 0.0
    cpu_usage_percent: float = 0.0
    network_latency_ms: float = 0.0
    error_rate_percent: float = 0.0
    uptime_seconds: float = 0.0
    cycles_per_hour: float = 0.0
    api_calls_per_minute: float = 0.0

@dataclass
class TradingStatistics:
    """–†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è —Ç–æ—Ä–≥–æ–≤–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"""
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    total_profit_usd: float = 0.0
    total_loss_usd: float = 0.0
    win_rate: float = 0.0
    profit_factor: float = 0.0
    max_drawdown: float = 0.0
    max_drawdown_duration: int = 0
    average_win: float = 0.0
    average_loss: float = 0.0
    largest_win: float = 0.0
    largest_loss: float = 0.0
    consecutive_wins: int = 0
    consecutive_losses: int = 0
    max_consecutive_wins: int = 0
    max_consecutive_losses: int = 0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0
    trades_per_day: float = 0.0
    average_trade_duration: float = 0.0
    start_balance: float = 0.0
    current_balance: float = 0.0
    peak_balance: float = 0.0
    roi_percent: float = 0.0

# =================================================================
# –ì–õ–ê–í–ù–´–ô –ö–õ–ê–°–° BOTMANAGER
# =================================================================

class BotManager:
    """
    –ü–û–õ–ù–û–¶–ï–ù–ù–´–ô –ú–µ–Ω–µ–¥–∂–µ—Ä —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –±–æ—Ç–∞ —Å –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ –≤–∞–ª—é—Ç–∞–º–∏
    
    –ù–û–í–´–ï –í–û–ó–ú–û–ñ–ù–û–°–¢–ò:
    ‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –∏ –∞–Ω–∞–ª–∏–∑ –¥–æ 200 —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä
    ‚úÖ 7+ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π —Å –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–º –≤—ã–±–æ—Ä–æ–º
    ‚úÖ –ú–∞—à–∏–Ω–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ–≥–Ω–æ–∑–∏—Ä–æ–≤–∞–Ω–∏—è —Ü–µ–Ω
    ‚úÖ –ê–Ω–∞–ª–∏–∑ –Ω–æ–≤–æ—Å—Ç–µ–π –∏ —Å–æ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å–µ—Ç–µ–π  
    ‚úÖ –°–∏—Å—Ç–µ–º–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–∏—Å–∫–∞–º–∏ —Å –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–æ–Ω–Ω—ã–º –∞–Ω–∞–ª–∏–∑–æ–º
    ‚úÖ –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ —Ü–∏–∫–ª—ã –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
    ‚úÖ –°–∏—Å—Ç–µ–º–∞ –∑–¥–æ—Ä–æ–≤—å—è –∏ —Å–∞–º–æ–≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
    ‚úÖ –ë—ç–∫—Ç–µ—Å—Ç–∏–Ω–≥ –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    ‚úÖ –≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö –∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∞
    ‚úÖ –ü–æ–ª–Ω–∞—è –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è —Ç–æ—Ä–≥–æ–≤–ª–∏
    """
    
    _instance = None
    _initialized = False
    
    def __new__(cls):
        """–ü–∞—Ç—Ç–µ—Ä–Ω Singleton"""
        if cls._instance is None:
            cls._instance = super(BotManager, cls).__new__(cls)
        return cls._instance
    
    def __init__(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –±–æ—Ç–∞ - –ü–û–õ–ù–ê–Ø –í–ï–†–°–ò–Ø"""
        if BotManager._initialized:
            return
            
        BotManager._initialized = True
        logger.info("üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ü–û–õ–ù–û–¶–ï–ù–ù–û–ì–û BotManager...")
        
        # === –û–°–ù–û–í–ù–´–ï –ê–¢–†–ò–ë–£–¢–´ ===
        self.status = BotStatus.STOPPED
        self.start_time = None
        self.stop_time = None
        self.pause_time = None
        
        # === –¢–û–†–ì–û–í–´–ï –ü–ê–†–´ - –†–ê–°–®–ò–†–ï–ù–û ===
        self.all_trading_pairs = []          # –í—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –ø–∞—Ä—ã
        self.active_pairs = []               # –ê–∫—Ç–∏–≤–Ω—ã–µ –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏
        self.inactive_pairs = []             # –ù–µ–∞–∫—Ç–∏–≤–Ω—ã–µ –ø–∞—Ä—ã
        self.blacklisted_pairs = set()       # –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–∞—Ä—ã
        self.watchlist_pairs = []            # –°–ø–∏—Å–æ–∫ –Ω–∞–±–ª—é–¥–µ–Ω–∏—è
        self.trending_pairs = []             # –¢—Ä–µ–Ω–¥–æ–≤—ã–µ –ø–∞—Ä—ã
        self.high_volume_pairs = []          # –í—ã—Å–æ–∫–æ–æ–±—ä–µ–º–Ω—ã–µ –ø–∞—Ä—ã
        
        # === –ü–û–ó–ò–¶–ò–ò –ò –°–î–ï–õ–ö–ò ===
        self.positions = {}                  # –û—Ç–∫—Ä—ã—Ç—ã–µ –ø–æ–∑–∏—Ü–∏–∏ {symbol: position_info}
        self.pending_orders = {}             # –û–∂–∏–¥–∞—é—â–∏–µ –æ—Ä–¥–µ—Ä–∞
        self.executed_trades = []            # –í—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ —Å–¥–µ–ª–∫–∏
        self.failed_trades = []              # –ù–µ—É–¥–∞—á–Ω—ã–µ —Å–¥–µ–ª–∫–∏
        self.trades_today = 0               # –°—á–µ—Ç—á–∏–∫ —Å–¥–µ–ª–æ–∫ –∑–∞ –¥–µ–Ω—å
        self.daily_profit = 0.0             # –ü—Ä–∏–±—ã–ª—å –∑–∞ –¥–µ–Ω—å
        self.weekly_profit = 0.0            # –ü—Ä–∏–±—ã–ª—å –∑–∞ –Ω–µ–¥–µ–ª—é
        self.monthly_profit = 0.0           # –ü—Ä–∏–±—ã–ª—å –∑–∞ –º–µ—Å—è—Ü
        
        # === –¶–ò–ö–õ–´ –ò –ó–ê–î–ê–ß–ò ===
        self.cycles_count = 0               # –°—á–µ—Ç—á–∏–∫ —Ü–∏–∫–ª–æ–≤
        self._stop_event = asyncio.Event()  # –°–æ–±—ã—Ç–∏–µ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
        self._pause_event = asyncio.Event() # –°–æ–±—ã—Ç–∏–µ –ø–∞—É–∑—ã
        self._main_task = None              # –û—Å–Ω–æ–≤–Ω–∞—è –∑–∞–¥–∞—á–∞
        self.tasks = {}                     # –ê–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–¥–∞—á–∏
        self.task_health = {}               # –ó–¥–æ—Ä–æ–≤—å–µ –∑–∞–¥–∞—á
        
        # === –ö–û–ú–ü–û–ù–ï–ù–¢–´ –°–ò–°–¢–ï–ú–´ ===
        self.components = {}                # –í—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Å–∏—Å—Ç–µ–º—ã
        self.component_manager = None       # –ú–µ–Ω–µ–¥–∂–µ—Ä –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
        self.exchange = None               # –ö–ª–∏–µ–Ω—Ç –±–∏—Ä–∂–∏
        self.market_analyzer = None        # –ê–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä —Ä—ã–Ω–∫–∞
        self.trader = None                 # –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å —Å–¥–µ–ª–æ–∫
        self.risk_manager = None           # –ú–µ–Ω–µ–¥–∂–µ—Ä —Ä–∏—Å–∫–æ–≤
        self.portfolio_manager = None      # –ú–µ–Ω–µ–¥–∂–µ—Ä –ø–æ—Ä—Ç—Ñ–µ–ª—è
        self.notifier = None              # –°–∏—Å—Ç–µ–º–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
        self.data_collector = None        # –°–±–æ—Ä—â–∏–∫ –¥–∞–Ω–Ω—ã—Ö
        self.strategy_factory = None      # –§–∞–±—Ä–∏–∫–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
        
        # === –°–¢–†–ê–¢–ï–ì–ò–ò - –†–ê–°–®–ò–†–ï–ù–û ===
        self.available_strategies = config.ENABLED_STRATEGIES
        self.strategy_instances = {}       # –≠–∫–∑–µ–º–ø–ª—è—Ä—ã —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
        self.balance = 0.0
        self.available_balance = 0.0
        self.trades_today = 0
        self.positions = {}
        self.candle_cache = {}
        self.price_history = {}
        
        # === –°–ß–ï–¢–ß–ò–ö–ò –ò –°–¢–ê–¢–ò–°–¢–ò–ö–ê ===
        self.cycle_count = 0
        self.last_balance_update = None
        self.daily_pnl = 0.0
        self.total_pnl = 0.0
        self.stop_requested = False
        self.strategy_performance = defaultdict(lambda: {
            'total_trades': 0,
            'winning_trades': 0,
            'losing_trades': 0,
            'total_profit': 0.0,
            'win_rate': 0.0,
            'avg_profit_per_trade': 0.0,
            'max_drawdown': 0.0,
            'sharpe_ratio': 0.0,
            'sortino_ratio': 0.0,
            'last_used': None,
            'enabled': True,
            'confidence_scores': deque(maxlen=100),
            'recent_performance': deque(maxlen=50)
        })
        
        # === –¢–û–†–ì–û–í–´–ï –í–û–ó–ú–û–ñ–ù–û–°–¢–ò ===
        self.current_opportunities = {}     # –¢–µ–∫—É—â–∏–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ {symbol: opportunity}
        self.opportunity_history = deque(maxlen=1000)  # –ò—Å—Ç–æ—Ä–∏—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π
        self.missed_opportunities = deque(maxlen=100)  # –£–ø—É—â–µ–Ω–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏
        
        # === –†–´–ù–û–ß–ù–´–ï –î–ê–ù–ù–´–ï - –†–ê–°–®–ò–†–ï–ù–û ===
        self.market_state = MarketState(
            overall_trend="UNKNOWN",
            volatility="MEDIUM",
            fear_greed_index=50,
            market_cap=0.0,
            volume_24h=0.0,
            dominance_btc=0.0,
            dominance_eth=0.0,
            active_pairs_count=0,
            trending_pairs=[],
            declining_pairs=[],
            correlation_matrix={},
            sector_performance={},
            market_regime="SIDEWAYS_MARKET",
            risk_level=RiskLevel.MEDIUM
        )
        
        # === –ö–≠–®–ò–†–û–í–ê–ù–ò–ï –î–ê–ù–ù–´–• ===
        self.market_data_cache = {}         # –ö—ç—à —Ä—ã–Ω–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö {symbol: data}
        self.price_history = defaultdict(lambda: deque(maxlen=1000))  # –ò—Å—Ç–æ—Ä–∏—è —Ü–µ–Ω
        self.volume_history = defaultdict(lambda: deque(maxlen=1000))  # –ò—Å—Ç–æ—Ä–∏—è –æ–±—ä–µ–º–æ–≤
        self.indicator_cache = defaultdict(dict)  # –ö—ç—à –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
        self.candle_cache = defaultdict(lambda: deque(maxlen=500))  # –ö—ç—à —Å–≤–µ—á–µ–π
        
        # === –ú–ê–®–ò–ù–ù–û–ï –û–ë–£–ß–ï–ù–ò–ï ===
        self.ml_models = {}                # ML –º–æ–¥–µ–ª–∏ {symbol: model}
        self.ml_predictions = {}           # ML –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è {symbol: prediction}
        self.feature_cache = {}            # –ö—ç—à –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ –¥–ª—è ML
        self.model_performance = defaultdict(dict)  # –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –º–æ–¥–µ–ª–µ–π
        self.training_queue = asyncio.Queue()  # –û—á–µ—Ä–µ–¥—å –æ–±—É—á–µ–Ω–∏—è
        self.prediction_cache = {}         # –ö—ç—à –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π
        
        # === –ê–ù–ê–õ–ò–ó –ù–û–í–û–°–¢–ï–ô ===
        self.news_cache = deque(maxlen=1000)  # –ö—ç—à –Ω–æ–≤–æ—Å—Ç–µ–π
        self.news_sentiment = {}           # –ù–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –Ω–æ–≤–æ—Å—Ç–µ–π {symbol: sentiment}
        self.social_signals = deque(maxlen=500)  # –°–æ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã
        self.sentiment_analyzer = None     # –ê–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–π
        self.news_sources = []            # –ò—Å—Ç–æ—á–Ω–∏–∫–∏ –Ω–æ–≤–æ—Å—Ç–µ–π
        
        # === –†–ò–°–ö-–ú–ï–ù–ï–î–ñ–ú–ï–ù–¢ ===
        self.risk_limits = {
            'max_portfolio_risk': config.MAX_PORTFOLIO_RISK_PERCENT / 100,
            'max_daily_loss': config.MAX_DAILY_LOSS_PERCENT / 100,
            'max_correlation': config.MAX_CORRELATION_THRESHOLD,
            'max_positions': config.MAX_POSITIONS,
            'max_daily_trades': config.MAX_DAILY_TRADES
        }
        self.correlation_matrix = {}       # –ú–∞—Ç—Ä–∏—Ü–∞ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–π
        self.portfolio_risk = 0.0         # –¢–µ–∫—É—â–∏–π —Ä–∏—Å–∫ –ø–æ—Ä—Ç—Ñ–µ–ª—è
        self.daily_loss = 0.0             # –î–Ω–µ–≤–Ω—ã–µ –ø–æ—Ç–µ—Ä–∏
        self.risk_alerts = []             # –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –æ —Ä–∏—Å–∫–∞—Ö
        
        # === –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–¨ ===
        self.performance_metrics = PerformanceMetrics()
        self.system_stats = {}            # –°–∏—Å—Ç–µ–º–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        self.api_call_count = defaultdict(int)  # –°—á–µ—Ç—á–∏–∫–∏ API –≤—ã–∑–æ–≤–æ–≤
        self.error_count = defaultdict(int)     # –°—á–µ—Ç—á–∏–∫–∏ –æ—à–∏–±–æ–∫
        self.latency_measurements = deque(maxlen=100)  # –ò–∑–º–µ—Ä–µ–Ω–∏—è –∑–∞–¥–µ—Ä–∂–∫–∏
        
        # === –°–¢–ê–¢–ò–°–¢–ò–ö–ê - –†–ê–°–®–ò–†–ï–ù–ù–ê–Ø ===
        self.trading_stats = TradingStatistics()
        self.strategy_stats = defaultdict(lambda: TradingStatistics())
        self.pair_stats = defaultdict(lambda: TradingStatistics())
        self.daily_stats = defaultdict(lambda: TradingStatistics())
        
        # === –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ===
        self.config = config
        self.trading_pairs = config.get_active_trading_pairs()
        self.strategy = 'auto'
        self.mode = 'live' if not config.TEST_MODE else 'test'
        
        # === –°–û–ë–´–¢–ò–Ø –ò –°–õ–£–®–ê–¢–ï–õ–ò ===
        self.event_listeners = defaultdict(list)  # –°–ª—É—à–∞—Ç–µ–ª–∏ —Å–æ–±—ã—Ç–∏–π
        self.event_queue = asyncio.Queue()  # –û—á–µ—Ä–µ–¥—å —Å–æ–±—ã—Ç–∏–π
        
        # === –ë–≠–ö–¢–ï–°–¢–ò–ù–ì ===
        self.backtesting_enabled = config.ENABLE_BACKTESTING
        self.backtest_results = {}
        self.optimization_results = {}
        
        # === –≠–ö–°–ü–û–†–¢ –ò –õ–û–ì–ò–†–û–í–ê–ù–ò–ï ===
        self.export_queue = asyncio.Queue()  # –û—á–µ—Ä–µ–¥—å —ç–∫—Å–ø–æ—Ä—Ç–∞
        self.log_buffer = deque(maxlen=10000)  # –ë—É—Ñ–µ—Ä –ª–æ–≥–æ–≤
        
        # === –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–¨ ===
        self.circuit_breaker_active = False
        self.emergency_stop_triggered = False
        self.suspicious_activity = []
        
        # === WEBSOCKET –ò –†–ï–ê–õ–¨–ù–û–ï –í–†–ï–ú–Ø ===
        self.websocket_connections = {}
        self.real_time_data = {}
        self.price_alerts = {}
        
        # === THREAD POOL ===
        self.thread_pool = ThreadPoolExecutor(max_workers=config.MAX_CONCURRENT_ANALYSIS)
        
        self.exchange_client = None
        self._exchange_initialized = False
        self.enhanced_exchange_client = None
        self.v5_integration_enabled = False
        
        logger.info("ü§ñ –ü–û–õ–ù–û–¶–ï–ù–ù–´–ô BotManager –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
        logger.info(f"üìä –ú–∞–∫—Å–∏–º—É–º —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä: {config.MAX_TRADING_PAIRS}")
        logger.info(f"üìà –ú–∞–∫—Å–∏–º—É–º –ø–æ–∑–∏—Ü–∏–π: {config.MAX_POSITIONS}")
        logger.info(f"üéØ –ê–∫—Ç–∏–≤–Ω—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏: {len(self.available_strategies)}")
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
        self._initialization_completed = False
    
    async def initialize(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫"""
        max_init_attempts = 3
        
        for attempt in range(max_init_attempts):
            try:
                logger.info(f"üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è BotManager (–ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{max_init_attempts})")
                
                # ‚úÖ –ë–ï–ó–û–ü–ê–°–ù–´–ô –ò–ú–ü–û–†–¢
                try:
                    from ..exchange.unified_exchange import get_real_exchange_client
                except ImportError as e:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ exchange client: {e}")
                    return False
                
                # ‚úÖ –ü–†–ï–î–û–¢–í–†–ê–©–ê–ï–ú –ü–û–í–¢–û–†–ù–£–Æ –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Æ
                if hasattr(self, 'exchange_client') and self.exchange_client and self.exchange_client.is_connected:
                    logger.info("‚úÖ Exchange client —É–∂–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –∏ –ø–æ–¥–∫–ª—é—á–µ–Ω")
                    return True
                
                # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –∫–ª–∏–µ–Ω—Ç
                self.exchange_client = get_real_exchange_client()
                
                # –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è —Å retry –ª–æ–≥–∏–∫–æ–π
                connection_attempts = 0
                max_connection_attempts = 3
                
                while connection_attempts < max_connection_attempts:
                    logger.info(f"üîó –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–∏—Ä–∂–µ (–ø–æ–ø—ã—Ç–∫–∞ {connection_attempts + 1})")
                    
                    connected = await self.exchange_client.connect()
                    
                    if connected and self.exchange_client.is_connected:
                        logger.info("‚úÖ –£—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–µ–Ω –∫ –±–∏—Ä–∂–µ")
                        break
                    else:
                        connection_attempts += 1
                        if connection_attempts < max_connection_attempts:
                            wait_time = min(30, 5 * connection_attempts)
                            logger.warning(f"‚è≥ –ñ–¥–µ–º {wait_time}—Å –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–æ–π...")
                            await asyncio.sleep(wait_time)
                
                if not self.exchange_client.is_connected:
                    raise Exception(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ –±–∏—Ä–∂–µ –ø–æ—Å–ª–µ {max_connection_attempts} –ø–æ–ø—ã—Ç–æ–∫")
                
                logger.info("‚úÖ BotManager —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
                return True
                
            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ (–ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}): {e}")
                
                if attempt < max_init_attempts - 1:
                    wait_time = min(60, 10 * (attempt + 1))
                    logger.info(f"‚è≥ –ñ–¥–µ–º {wait_time}—Å –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–µ–π...")
                    await asyncio.sleep(wait_time)
                else:
                    logger.error("‚ùå –í—Å–µ –ø–æ–ø—ã—Ç–∫–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∏—Å—á–µ—Ä–ø–∞–Ω—ã")
                    return False
        
        return False
    
    async def _initialize_components(self):
        """
        –ê–ª–∏–∞—Å –¥–ª—è _initialize_all_components() –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
        
        ‚ùå –û—à–∏–±–∫–∞ –±—ã–ª–∞ –≤ —Ç–æ–º, —á—Ç–æ –≤ __init__ –≤—ã–∑—ã–≤–∞–ª—Å—è:
        self._initialization_completed = False
        
        ‚úÖ –ê —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –º–µ—Ç–æ–¥ –Ω–∞–∑—ã–≤–∞–ª—Å—è:
        async def _initialize_all_components(self)
        
        ‚úÖ –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ —Ä–µ—à–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—É, —Å–æ—Ö—Ä–∞–Ω—è—è –≤—Å—é —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å
        """
        
        return await self._initialize_all_components()
    
    # =================================================================
    # –û–°–ù–û–í–ù–´–ï –ú–ï–¢–û–î–´ –£–ü–†–ê–í–õ–ï–ù–ò–Ø
    # =================================================================
    
    async def _update_market_data(self):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä—ã–Ω–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≤—Å–µ—Ö —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä"""
        try:
            logger.debug("üìä –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä—ã–Ω–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö...")
            
            updated_pairs = 0
            for symbol in self.active_pairs:
                try:
                    # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ–º data_collector –µ—Å–ª–∏ –æ–Ω –¥–æ—Å—Ç—É–ø–µ–Ω
                    if hasattr(self, 'data_collector') and self.data_collector:
                        # –°–æ–±–∏—Ä–∞–µ–º –¥–∞–Ω–Ω—ã–µ —á–µ—Ä–µ–∑ data_collector
                        market_data = await self.data_collector.collect_market_data(symbol)
                        
                        # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–ª–æ–≤–∞—Ä—è
                        if market_data and isinstance(market_data, dict):
                            # –°–æ—Ö—Ä–∞–Ω—è–µ–º candles –≤ –∫—ç—à –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
                            if 'candles' in market_data and market_data['candles']:
                                if symbol not in self.candle_cache:
                                    self.candle_cache[symbol] = deque(maxlen=100)
                                
                                # –î–æ–±–∞–≤–ª—è–µ–º —Å–≤–µ—á–∏ –≤ –∫—ç—à
                                for candle in market_data['candles']:
                                    self.candle_cache[symbol].append(candle)
                            
                            # –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é —Ü–µ–Ω—É
                            if 'ticker' in market_data and market_data['ticker']:
                                last_price = float(market_data['ticker'].get('last', 0))
                                
                                if symbol not in self.price_history:
                                    self.price_history[symbol] = deque(maxlen=100)
                                
                                self.price_history[symbol].append({
                                    'price': last_price,
                                    'volume': float(market_data['ticker'].get('volume', 0)),
                                    'timestamp': datetime.utcnow()
                                })
                                
                                updated_pairs += 1
                                logger.debug(f"üìà {symbol}: ${last_price:.4f}")
                    else:
                        # Fallback: –ø–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –Ω–∞–ø—Ä—è–º—É—é —á–µ—Ä–µ–∑ exchange
                        if hasattr(self.exchange_client, 'get_klines'):
                            candles = await self.exchange_client.get_klines(
                                symbol=symbol,
                                interval='5m',
                                limit=50
                            )
                        elif hasattr(self.exchange_client, 'fetch_ohlcv'):
                            candles = await self.exchange_client.fetch_ohlcv(
                                symbol, '5m', limit=50
                            )
                        else:
                            logger.warning(f"‚ö†Ô∏è –ú–µ—Ç–æ–¥ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–≤–µ—á–µ–π –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è {symbol}")
                            continue
                        
                        if candles and len(candles) > 0:
                            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –∫—ç—à
                            if symbol not in self.candle_cache:
                                self.candle_cache[symbol] = deque(maxlen=100)
                            
                            # –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ —Å–≤–µ—á–∏
                            for candle in candles[-10:]:  # –ü–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Å–≤–µ—á–µ–π
                                candle_data = {
                                    'timestamp': candle[0] if isinstance(candle, list) else candle.get('timestamp'),
                                    'open': float(candle[1] if isinstance(candle, list) else candle.get('open', 0)),
                                    'high': float(candle[2] if isinstance(candle, list) else candle.get('high', 0)),
                                    'low': float(candle[3] if isinstance(candle, list) else candle.get('low', 0)),
                                    'close': float(candle[4] if isinstance(candle, list) else candle.get('close', 0)),
                                    'volume': float(candle[5] if isinstance(candle, list) else candle.get('volume', 0))
                                }
                                self.candle_cache[symbol].append(candle_data)
                            
                            # –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é —Ü–µ–Ω—É
                            last_candle = candles[-1]
                            last_price = float(last_candle[4] if isinstance(last_candle, list) else last_candle.get('close', 0))
                            
                            if symbol not in self.price_history:
                                self.price_history[symbol] = deque(maxlen=100)
                            
                            self.price_history[symbol].append({
                                'price': last_price,
                                'volume': float(last_candle[5] if isinstance(last_candle, list) else last_candle.get('volume', 0)),
                                'timestamp': datetime.utcnow()
                            })
                            
                            updated_pairs += 1
                            logger.debug(f"üìà {symbol}: ${last_price:.4f}")
                            
                except Exception as e:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö {symbol}: {e}")
            
            if updated_pairs > 0:
                logger.debug(f"‚úÖ –û–±–Ω–æ–≤–ª–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –¥–ª—è {updated_pairs}/{len(self.active_pairs)} –ø–∞—Ä")
            else:
                logger.warning("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –Ω–∏ –¥–ª—è –æ–¥–Ω–æ–π –ø–∞—Ä—ã")
                
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ä—ã–Ω–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö: {e}")
            logger.error(traceback.format_exc())
    
    async def _find_all_trading_opportunities(self):
        """–ü–æ–∏—Å–∫ —Ç–æ—Ä–≥–æ–≤—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π –ø–æ –≤—Å–µ–º –ø–∞—Ä–∞–º –∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏—è–º"""
        opportunities = []
        
        try:
            logger.debug("üîç –ü–æ–∏—Å–∫ —Ç–æ—Ä–≥–æ–≤—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π...")
            
            for symbol in self.active_pairs:
                try:
                    # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
                    market_data = self._prepare_market_data(symbol)
                    
                    if not market_data or len(market_data.get('close', [])) < 20:
                        logger.debug(f"‚ö†Ô∏è –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ {symbol}")
                        continue
                    
                    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ DataFrame –¥–ª—è ML –∞–Ω–∞–ª–∏–∑–∞
                    df = self._market_data_to_dataframe(market_data)
                    
                    # –ê–Ω–∞–ª–∏–∑ –±–∞–∑–æ–≤–æ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–µ–π
                    signal = await self._analyze_with_basic_strategy(symbol, market_data)
                    
                    if signal and signal.get('signal') != 'HOLD':
                        opportunity = {
                            'symbol': symbol,
                            'strategy': 'basic',
                            'signal': signal['signal'],
                            'confidence': signal.get('confidence', 0.5),
                            'price': float(market_data['close'][-1]),
                            'timestamp': datetime.utcnow(),
                            'reasons': signal.get('reasons', ['basic_signal'])
                        }
                        
                        opportunities.append(opportunity)
                        logger.info(f"üéØ –ù–∞–π–¥–µ–Ω–∞ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å: {symbol} {signal['signal']} (—É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {signal.get('confidence', 0):.2f})")
                    
                    # ‚úÖ ML –ê–ù–ê–õ–ò–ó (–¥–æ–±–∞–≤–ª–µ–Ω —Å–æ–≥–ª–∞—Å–Ω–æ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏)
                    if getattr(self.config, 'ENABLE_MACHINE_LEARNING', False) and hasattr(self, 'ml_system') and self.ml_system:
                        ml_signal = await self._analyze_with_ml(symbol, df)
                        if ml_signal:
                            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å
                            if ml_signal['confidence'] >= getattr(self.config, 'ML_PREDICTION_THRESHOLD', 0.7):
                                opportunities.append(ml_signal)
                                logger.info(f"ü§ñ ML —Å–∏–≥–Ω–∞–ª: {symbol} {ml_signal['signal']} (—É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {ml_signal['confidence']:.2%})")
                            else:
                                logger.debug(f"ü§ñ ML —Å–∏–≥–Ω–∞–ª –æ—Ç–∫–ª–æ–Ω–µ–Ω: –Ω–∏–∑–∫–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å {ml_signal['confidence']:.2%}")
                    
                except Exception as e:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ {symbol}: {e}")
            
            logger.info(f"üìä –ù–∞–π–¥–µ–Ω–æ —Ç–æ—Ä–≥–æ–≤—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π: {len(opportunities)}")
            return opportunities
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ —Ç–æ—Ä–≥–æ–≤—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π: {e}")
            logger.error(traceback.format_exc())
            return []
    
    # ‚úÖ –ù–û–í–´–ô –ú–ï–¢–û–î –¥–ª—è ML –∞–Ω–∞–ª–∏–∑–∞ (–∏–∑ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏):
    async def _analyze_with_ml(self, symbol: str, df: pd.DataFrame) -> Optional[Dict[str, Any]]:
        """‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ê–Ω–∞–ª–∏–∑ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º ML –º–æ–¥–µ–ª–µ–π"""
        try:
            if not hasattr(self, 'ml_system') or not self.ml_system:
                return None
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ ML –≤–∫–ª—é—á–µ–Ω –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
            if not getattr(self.config, 'ENABLE_MACHINE_LEARNING', False):
                return None
            
            # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ –æ–±—Ä–∞—â–µ–Ω–∏–µ –∫ ML –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞–º
            direction_prediction = None
            
            # –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
            try:
                # –°–ø–æ—Å–æ–± 1: –ß–µ—Ä–µ–∑ trainer (–µ—Å–ª–∏ –µ—Å—Ç—å)
                if hasattr(self.ml_system, 'trainer') and self.ml_system.trainer:
                    if hasattr(self.ml_system.trainer, 'predict_direction'):
                        direction_prediction = await self.ml_system.trainer.predict_direction(symbol, df)
                    elif hasattr(self.ml_system.trainer, 'predict'):
                        direction_prediction = await self.ml_system.trainer.predict(symbol, df)
                
                # –°–ø–æ—Å–æ–± 2: –ß–µ—Ä–µ–∑ direction_classifier (–µ—Å–ª–∏ trainer –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª)
                if not direction_prediction and hasattr(self.ml_system, 'direction_classifier'):
                    if hasattr(self.ml_system.direction_classifier, 'predict'):
                        # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–∏–∑–Ω–∞–∫–∏
                        features = self.ml_system.feature_engineer.create_features(df, symbol) if hasattr(self.ml_system, 'feature_engineer') else df
                        
                        # –ü–æ–ª—É—á–∞–µ–º –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
                        prediction_result = self.ml_system.direction_classifier.predict(features)
                        
                        if 'error' not in prediction_result:
                            # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –Ω—É–∂–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç
                            direction_prediction = {
                                'direction': prediction_result.get('direction_labels', ['HOLD'])[-1] if prediction_result.get('direction_labels') else 'HOLD',
                                'confidence': prediction_result.get('confidence', [0.5])[-1] if prediction_result.get('confidence') else 0.5,
                                'features': {},
                                'model_type': 'direction_classifier'
                            }
                
                # –°–ø–æ—Å–æ–± 3: –°–æ–∑–¥–∞–µ–º –∑–∞–≥–ª—É—à–∫—É, –µ—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å
                if not direction_prediction:
                    logger.warning("‚ö†Ô∏è ML –º–æ–¥–µ–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞–≥–ª—É—à–∫—É")
                    direction_prediction = {
                        'direction': 'HOLD',
                        'confidence': 0.3,  # –ù–∏–∑–∫–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –¥–ª—è –∑–∞–≥–ª—É—à–∫–∏
                        'features': {},
                        'model_type': 'fallback'
                    }
                    
            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è ML –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è: {e}")
                return None
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å
            min_confidence = getattr(self.config, 'ML_PREDICTION_THRESHOLD', 0.7)
            if direction_prediction.get('confidence', 0) < min_confidence:
                logger.debug(f"ü§ñ ML –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ: —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å {direction_prediction.get('confidence', 0):.2f} < {min_confidence}")
                return None
                
            # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü–æ–ª—É—á–µ–Ω–∏–µ price_prediction
            price_prediction = {
                'support': df['close'].iloc[-1] * 0.98, 
                'resistance': df['close'].iloc[-1] * 1.02,
                'confidence': 0.5
            }
            
            try:
                if hasattr(self.ml_system, 'price_regressor'):
                    # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Ä–µ–∞–ª—å–Ω–æ–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ —Ü–µ–Ω—ã
                    pass
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ price_prediction: {e}")
            
            # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü–æ–ª—É—á–µ–Ω–∏–µ RL recommendation  
            rl_recommendation = None
            try:
                if hasattr(self.ml_system, 'rl_agent') and self.ml_system.rl_agent:
                    # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å RL –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
                    pass
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ RL recommendation: {e}")
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–æ—Ä–≥–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª
            ml_signal = {
                'symbol': symbol,
                'signal': direction_prediction.get('direction', 'HOLD'),
                'price': df['close'].iloc[-1],
                'confidence': direction_prediction['confidence'],
                'stop_loss': price_prediction.get('support', df['close'].iloc[-1] * 0.98),
                'take_profit': price_prediction.get('resistance', df['close'].iloc[-1] * 1.02),
                'strategy': 'ml_prediction',
                'ml_features': direction_prediction.get('features', {}),
                'price_targets': price_prediction.get('targets', {}),
                'rl_action': rl_recommendation.get('action') if rl_recommendation else None,
                'indicators': {
                    'ml_direction_confidence': direction_prediction['confidence'],
                    'ml_price_confidence': price_prediction.get('confidence', 0),
                    'feature_importance': direction_prediction.get('feature_importance', {}),
                    'model_type': direction_prediction.get('model_type', 'ensemble')
                }
            }
            
            logger.debug(f"ü§ñ ML —Å–∏–≥–Ω–∞–ª –¥–ª—è {symbol}: {ml_signal['signal']} (—É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {ml_signal['confidence']:.2f})")
            return ml_signal
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ ML –∞–Ω–∞–ª–∏–∑–∞ –¥–ª—è {symbol}: {e}")
            return None
    
    def _market_data_to_dataframe(self, market_data: dict) -> pd.DataFrame:
        """–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Ä—ã–Ω–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –≤ DataFrame –¥–ª—è ML"""
        try:
            df = pd.DataFrame({
                'open': market_data['open'],
                'high': market_data['high'],
                'low': market_data['low'],
                'close': market_data['close'],
                'volume': market_data['volume']
            })
            
            # –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ—Å—Ç—ã–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –¥–ª—è ML
            df['rsi'] = self._calculate_rsi(df['close'], 14)
            df['macd'] = self._calculate_macd(df['close'])
            df['bb_position'] = self._calculate_bb_position(df['close'])
            df['volume_ratio'] = df['volume'] / df['volume'].rolling(20).mean()
            df['price_change'] = df['close'].pct_change() * 100
            
            return df.fillna(0)
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –≤ DataFrame: {e}")
            return pd.DataFrame()
    
    def _calculate_rsi(self, prices: pd.Series, period: int = 14) -> pd.Series:
        """–†–∞—Å—á–µ—Ç RSI"""
        try:
            delta = prices.diff()
            gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
            rs = gain / loss
            rsi = 100 - (100 / (1 + rs))
            return rsi.fillna(50)
        except:
            return pd.Series([50] * len(prices))
    
    def _calculate_macd(self, prices: pd.Series) -> pd.Series:
        """–†–∞—Å—á–µ—Ç MACD"""
        try:
            exp1 = prices.ewm(span=12).mean()
            exp2 = prices.ewm(span=26).mean()
            macd = exp1 - exp2
            return macd.fillna(0)
        except:
            return pd.Series([0] * len(prices))
    
    def _calculate_bb_position(self, prices: pd.Series, period: int = 20) -> pd.Series:
        """–†–∞—Å—á–µ—Ç –ø–æ–∑–∏—Ü–∏–∏ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –ø–æ–ª–æ—Å –ë–æ–ª–ª–∏–Ω–¥–∂–µ—Ä–∞"""
        try:
            rolling_mean = prices.rolling(window=period).mean()
            rolling_std = prices.rolling(window=period).std()
            upper_band = rolling_mean + (rolling_std * 2)
            lower_band = rolling_mean - (rolling_std * 2)
            bb_position = (prices - lower_band) / (upper_band - lower_band)
            return bb_position.fillna(0.5)
        except:
            return pd.Series([0.5] * len(prices))
    
    async def _analyze_with_basic_strategy(self, symbol: str, market_data: dict):
        """–ë–∞–∑–æ–≤—ã–π –∞–Ω–∞–ª–∏–∑ –¥–ª—è –ø–æ–∏—Å–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ - –£–õ–£–ß–®–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø"""
        try:
            closes = market_data.get('close', [])
            volumes = market_data.get('volume', [])
            
            if len(closes) < 20:
                return None
            
            # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ numpy arrays –¥–ª—è –±—ã—Å—Ç—Ä—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏–π
            import numpy as np
            closes = np.array(closes[-50:])  # –ü–æ—Å–ª–µ–¥–Ω–∏–µ 50 —Å–≤–µ—á–µ–π
            volumes = np.array(volumes[-50:])
            
            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
            sma_20 = np.mean(closes[-20:])
            sma_10 = np.mean(closes[-10:])
            sma_5 = np.mean(closes[-5:])
            current_price = closes[-1]
            
            # RSI
            rsi = self._calculate_rsi_value(closes, 14)
            
            # –û–±—ä–µ–º
            volume_avg = np.mean(volumes[-20:])
            current_volume = volumes[-1]
            volume_ratio = current_volume / volume_avg if volume_avg > 0 else 1
            
            # MACD
            exp1 = pd.Series(closes).ewm(span=12).mean()
            exp2 = pd.Series(closes).ewm(span=26).mean()
            macd = exp1.iloc[-1] - exp2.iloc[-1]
            signal_line = (exp1 - exp2).ewm(span=9).mean().iloc[-1]
            macd_histogram = macd - signal_line
            
            # –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–µ–Ω—ã
            price_change_5 = (current_price - closes[-5]) / closes[-5] * 100
            price_change_10 = (current_price - closes[-10]) / closes[-10] * 100
            
            # === –£–õ–£–ß–®–ï–ù–ù–´–ï –£–°–õ–û–í–ò–Ø –î–õ–Ø –°–ò–ì–ù–ê–õ–û–í ===
            
            # BUY —Å–∏–≥–Ω–∞–ª—ã (–º–µ–Ω–µ–µ —Å—Ç—Ä–æ–≥–∏–µ —É—Å–ª–æ–≤–∏—è)
            buy_signals = 0
            
            # 1. –ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ MA —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö
            if sma_5 > sma_10 and closes[-2] < np.mean(closes[-11:-1]):
                buy_signals += 1
                
            # 2. RSI –≤—ã—Ö–æ–¥–∏—Ç –∏–∑ –ø–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω–Ω–æ—Å—Ç–∏
            if 25 < rsi < 45:  # –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω
                buy_signals += 1
                
            # 3. MACD –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç —Å–∏–≥–Ω–∞–ª—å–Ω—É—é –ª–∏–Ω–∏—é —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö
            if macd_histogram > 0 and macd > signal_line * 0.95:  # –ú–µ–Ω–µ–µ —Å—Ç—Ä–æ–≥–æ–µ —É—Å–ª–æ–≤–∏–µ
                buy_signals += 1
                
            # 4. –£–≤–µ–ª–∏—á–µ–Ω–∏–µ –æ–±—ä–µ–º–∞
            if volume_ratio > 1.2:  # –°–Ω–∏–∑–∏–ª–∏ –ø–æ—Ä–æ–≥
                buy_signals += 1
                
            # 5. –¶–µ–Ω–∞ —Ä–∞—Å—Ç–µ—Ç
            if price_change_5 > 0.5:  # –°–Ω–∏–∑–∏–ª–∏ –ø–æ—Ä–æ–≥
                buy_signals += 1
            
            # SELL —Å–∏–≥–Ω–∞–ª—ã
            sell_signals = 0
            
            # 1. –ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ MA —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑
            if sma_5 < sma_10 and closes[-2] > np.mean(closes[-11:-1]):
                sell_signals += 1
                
            # 2. RSI –≤ –ø–µ—Ä–µ–∫—É–ø–ª–µ–Ω–Ω–æ—Å—Ç–∏
            if rsi > 65:  # –°–Ω–∏–∑–∏–ª–∏ –ø–æ—Ä–æ–≥
                sell_signals += 1
                
            # 3. MACD –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç —Å–∏–≥–Ω–∞–ª—å–Ω—É—é –ª–∏–Ω–∏—é —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑
            if macd_histogram < 0 and macd < signal_line * 1.05:
                sell_signals += 1
                
            # 4. –¶–µ–Ω–∞ –ø–∞–¥–∞–µ—Ç
            if price_change_5 < -0.5:  # –°–Ω–∏–∑–∏–ª–∏ –ø–æ—Ä–æ–≥
                sell_signals += 1
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–∏–≥–Ω–∞–ª (–Ω—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º 2 –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –≤–º–µ—Å—Ç–æ 3)
            signal_type = 'HOLD'
            confidence = 0.0
            
            if buy_signals >= 2:  # –°–Ω–∏–∑–∏–ª–∏ –ø–æ—Ä–æ–≥ —Å 3 –¥–æ 2
                signal_type = 'BUY'
                confidence = buy_signals / 5.0
            elif sell_signals >= 2:  # –°–Ω–∏–∑–∏–ª–∏ –ø–æ—Ä–æ–≥ —Å 3 –¥–æ 2
                signal_type = 'SELL'
                confidence = sell_signals / 4.0
            
            if signal_type != 'HOLD':
                return {
                    'symbol': symbol,
                    'signal': signal_type,
                    'price': current_price,
                    'confidence': confidence,
                    'stop_loss': current_price * (0.97 if signal_type == 'BUY' else 1.03),
                    'take_profit': current_price * (1.06 if signal_type == 'BUY' else 0.94),
                    'indicators': {
                        'rsi': rsi,
                        'macd': macd,
                        'volume_ratio': volume_ratio,
                        'sma_trend': 'up' if sma_5 > sma_20 else 'down',
                        'price_change_5': price_change_5
                    }
                }
            
            return None
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –±–∞–∑–æ–≤–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ {symbol}: {e}")
            return None
    
    def _calculate_rsi_value(self, prices: np.ndarray, period: int = 14) -> float:
        """–†–∞—Å—á–µ—Ç RSI –∏–∑ numpy array"""
        try:
            deltas = np.diff(prices)
            gains = np.where(deltas > 0, deltas, 0)
            losses = np.where(deltas < 0, -deltas, 0)
            
            avg_gain = np.mean(gains[-period:])
            avg_loss = np.mean(losses[-period:])
            
            if avg_loss == 0:
                return 100
            
            rs = avg_gain / avg_loss
            rsi = 100 - (100 / (1 + rs))
            
            return rsi
        except:
            return 50
    
    async def _execute_real_order(self, symbol: str, signal: str, position_size: float,
                                 price: float, trade_data: Dict[str, Any]) -> bool:
        """
        –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –æ—Ä–¥–µ—Ä–∞ - –ü–û–õ–ù–û–°–¢–¨–Æ –ü–ï–†–ï–ü–ò–°–ê–ù–û
        
        Args:
            symbol: –¢–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 'BTCUSDT')
            signal: –¢–∏–ø —Å–∏–≥–Ω–∞–ª–∞ ('BUY' –∏–ª–∏ 'SELL')
            position_size: –†–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏
            price: –¶–µ–Ω–∞ –≤—Ö–æ–¥–∞
            trade_data: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å–¥–µ–ª–∫–∏
            
        Returns:
            bool: True –µ—Å–ª–∏ –æ—Ä–¥–µ—Ä –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ
        """
        try:
            logger.info(f"üí∏ –í–´–ü–û–õ–ù–ï–ù–ò–ï –†–ï–ê–õ–¨–ù–û–ô –°–î–ï–õ–ö–ò: {symbol} {signal}")
            logger.info(f"üí∞ –†–µ–∂–∏–º: {'TESTNET' if self.testnet else 'LIVE'}")
            
            # 1. –í–∞–ª–∏–¥–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
            if not self._validate_trade_params(symbol, signal, position_size, price):
                logger.error("‚ùå –í–∞–ª–∏–¥–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –Ω–µ –ø—Ä–æ–π–¥–µ–Ω–∞")
                return False
            
            # 2. –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –µ–¥–∏–Ω—ã–π —Ç–∏–ø —Å–∏–≥–Ω–∞–ª–∞
            try:
                from ..common.types import UnifiedTradingSignal, SignalAction
            except ImportError:
                logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å UnifiedTradingSignal")
                return False
            
            # 3. –°–æ–∑–¥–∞–µ–º —É–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–∏–≥–Ω–∞–ª
            unified_signal = UnifiedTradingSignal(
                symbol=symbol,
                action=SignalAction(signal.upper()),
                confidence=trade_data.get('confidence', 0.6),
                price=price,
                stop_loss=self._validate_stop_loss(signal, price, trade_data.get('stop_loss')),
                take_profit=self._validate_take_profit(signal, price, trade_data.get('take_profit')),
                reason=f"Signal from {trade_data.get('strategy', 'unknown')}",
                risk_reward_ratio=trade_data.get('risk_reward_ratio'),
                indicators=trade_data.get('indicators'),
                metadata=trade_data,
                strategy=trade_data.get('strategy', 'unknown'),
                source=trade_data.get('source', 'technical')
            )
            
            logger.info(f"üìä –£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–∏–≥–Ω–∞–ª —Å–æ–∑–¥–∞–Ω:")
            logger.info(f"   Symbol: {unified_signal.symbol}")
            logger.info(f"   Action: {unified_signal.action_str}")
            logger.info(f"   Side: {unified_signal.side_str}")
            logger.info(f"   Price: {unified_signal.price}")
            logger.info(f"   SL: {unified_signal.stop_loss}")
            logger.info(f"   TP: {unified_signal.take_profit}")
            
            # 4. –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è –≤ –ø–æ—Ä—è–¥–∫–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞
            
            # –°–ø–æ—Å–æ–± 1: Enhanced Exchange Client (—Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π Bybit V5)
            if hasattr(self, 'enhanced_exchange_client') and self.enhanced_exchange_client:
                try:
                    logger.info("üì° –ò—Å–ø–æ–ª—å–∑—É–µ–º Enhanced Exchange Client...")
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –ª–∏ –∫–ª–∏–µ–Ω—Ç –ø—Ä—è–º—É—é —Ä–∞–±–æ—Ç—É —Å —Å–∏–≥–Ω–∞–ª–∞–º–∏
                    if hasattr(self.enhanced_exchange_client, 'place_order_from_signal'):
                        result = await self.enhanced_exchange_client.place_order_from_signal(
                            signal=unified_signal,
                            amount=position_size
                        )
                    else:
                        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π place_order —Å params
                        result = await self.enhanced_exchange_client.place_order(
                            symbol=symbol,
                            side=signal.lower(),
                            amount=position_size,
                            price=price if trade_data.get('order_type') == 'limit' else None,
                            order_type=trade_data.get('order_type', 'market'),
                            params={
                                'stopLoss': unified_signal.stop_loss,
                                'takeProfit': unified_signal.take_profit,
                                'reduceOnly': False,
                                'timeInForce': 'GTC' if trade_data.get('order_type') == 'limit' else 'IOC'
                            }
                        )
                    
                    if result and result.get('success', False):
                        logger.info(f"‚úÖ –û—Ä–¥–µ—Ä –≤—ã–ø–æ–ª–Ω–µ–Ω —á–µ—Ä–µ–∑ Enhanced Client: {result.get('order_id')}")
                        self._save_order_info(result, unified_signal)
                        return True
                        
                except Exception as e:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ Enhanced Client: {e}")
            
            # –°–ø–æ—Å–æ–± 2: Execution Engine
            if hasattr(self, 'execution_engine') and self.execution_engine:
                try:
                    logger.info("üì° –ò—Å–ø–æ–ª—å–∑—É–µ–º Execution Engine...")
                    
                    # Execution Engine –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —Å –Ω–∞—à–∏–º —Ñ–æ—Ä–º–∞—Ç–æ–º
                    result = await self.execution_engine.execute_signal(
                        signal=unified_signal,
                        strategy_name=trade_data.get('strategy', 'unknown'),
                        market_conditions=trade_data.get('market_conditions', {})
                    )
                    
                    if result and hasattr(result, 'status') and result.status.value in ['completed', 'filled']:
                        logger.info(f"‚úÖ –û—Ä–¥–µ—Ä –≤—ã–ø–æ–ª–Ω–µ–Ω —á–µ—Ä–µ–∑ Execution Engine: {result.order_id}")
                        return True
                        
                except Exception as e:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ Execution Engine: {e}")
            
            # –°–ø–æ—Å–æ–± 3: –ë–∞–∑–æ–≤—ã–π Exchange Client
            if hasattr(self, 'exchange_client') and self.exchange_client:
                try:
                    logger.info("üì° –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–∞–∑–æ–≤—ã–π Exchange Client...")
                    
                    result = await self.exchange_client.place_order(
                        symbol=symbol,
                        side=signal.lower(),
                        amount=position_size,
                        price=price if trade_data.get('order_type') == 'limit' else None,
                        order_type=trade_data.get('order_type', 'market'),
                        params={
                            'stopLoss': unified_signal.stop_loss,
                            'takeProfit': unified_signal.take_profit
                        }
                    )
                    
                    if result and 'error' not in result:
                        logger.info(f"‚úÖ –û—Ä–¥–µ—Ä –≤—ã–ø–æ–ª–Ω–µ–Ω —á–µ—Ä–µ–∑ –±–∞–∑–æ–≤—ã–π Client: {result.get('id')}")
                        return True
                        
                except Exception as e:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ –±–∞–∑–æ–≤–æ–≥–æ Client: {e}")
            
            logger.error("‚ùå –í—Å–µ —Å–ø–æ—Å–æ–±—ã –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Å–¥–µ–ª–∫–∏ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–∏")
            return False
            
        except Exception as e:
            logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ _execute_real_order: {e}")
            import traceback
            traceback.print_exc()
            return False
            
    def _validate_trade_params(self, symbol: str, signal: str, 
                              position_size: float, price: float) -> bool:
        """
        –í–∞–ª–∏–¥–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Å–¥–µ–ª–∫–∏
        
        Args:
            symbol: –¢–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞
            signal: –¢–∏–ø —Å–∏–≥–Ω–∞–ª–∞
            position_size: –†–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏
            price: –¶–µ–Ω–∞
            
        Returns:
            bool: True –µ—Å–ª–∏ –≤—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤–∞–ª–∏–¥–Ω—ã
        """
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏–º–≤–æ–ª–∞
        if not symbol or not isinstance(symbol, str):
            logger.error(f"‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Å–∏–º–≤–æ–ª: {symbol}")
            return False
        
        if not symbol.endswith('USDT'):
            logger.warning(f"‚ö†Ô∏è –ù–µ–æ–±—ã—á–Ω—ã–π —Å–∏–º–≤–æ–ª (–Ω–µ USDT –ø–∞—Ä–∞): {symbol}")
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏–≥–Ω–∞–ª–∞
        if signal.upper() not in ['BUY', 'SELL']:
            logger.error(f"‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Å–∏–≥–Ω–∞–ª: {signal}")
            return False
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞ –ø–æ–∑–∏—Ü–∏–∏
        if not isinstance(position_size, (int, float)) or position_size <= 0:
            logger.error(f"‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏: {position_size}")
            return False
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–Ω—ã
        if not isinstance(price, (int, float)) or price <= 0:
            logger.error(f"‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Ü–µ–Ω–∞: {price}")
            return False
        
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
        min_position_size = 0.001  # –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –¥–ª—è BTC
        if position_size < min_position_size:
            logger.warning(f"‚ö†Ô∏è –†–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ –º–µ–Ω—å—à–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ: {position_size} < {min_position_size}")
        
        logger.info(f"‚úÖ –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–¥–µ–ª–∫–∏ –≤–∞–ª–∏–¥–Ω—ã: {symbol} {signal} size={position_size} price={price}")
        return True
    
    def _validate_stop_loss(self, signal: str, price: float, stop_loss: Optional[float]) -> Optional[float]:
        """–í–∞–ª–∏–¥–∞—Ü–∏—è –∏ –∫–æ—Ä—Ä–µ–∫—Ü–∏—è stop loss"""
        if not stop_loss:
            return None
            
        if signal.upper() == 'BUY':
            # –î–ª—è –ø–æ–∫—É–ø–∫–∏ SL –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–∏–∂–µ —Ü–µ–Ω—ã
            if stop_loss >= price:
                corrected = price * 0.97  # 3% –Ω–∏–∂–µ
                logger.warning(f"‚ö†Ô∏è SL —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω: {stop_loss} -> {corrected}")
                return corrected
        else:
            # –î–ª—è –ø—Ä–æ–¥–∞–∂–∏ SL –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤—ã—à–µ —Ü–µ–Ω—ã
            if stop_loss <= price:
                corrected = price * 1.03  # 3% –≤—ã—à–µ
                logger.warning(f"‚ö†Ô∏è SL —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω: {stop_loss} -> {corrected}")
                return corrected
        
        return stop_loss
    
    def _validate_take_profit(self, signal: str, price: float, take_profit: Optional[float]) -> Optional[float]:
        """–í–∞–ª–∏–¥–∞—Ü–∏—è –∏ –∫–æ—Ä—Ä–µ–∫—Ü–∏—è take profit"""
        if not take_profit:
            return None
            
        if signal.upper() == 'BUY':
            # –î–ª—è –ø–æ–∫—É–ø–∫–∏ TP –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤—ã—à–µ —Ü–µ–Ω—ã
            if take_profit <= price:
                corrected = price * 1.06  # 6% –≤—ã—à–µ
                logger.warning(f"‚ö†Ô∏è TP —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω: {take_profit} -> {corrected}")
                return corrected
        else:
            # –î–ª—è –ø—Ä–æ–¥–∞–∂–∏ TP –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–∏–∂–µ —Ü–µ–Ω—ã
            if take_profit >= price:
                corrected = price * 0.94  # 6% –Ω–∏–∂–µ
                logger.warning(f"‚ö†Ô∏è TP —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω: {take_profit} -> {corrected}")
                return corrected
        
        return take_profit
    
    def _save_order_info(self, order_result: Dict[str, Any], signal: 'UnifiedTradingSignal'):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –æ—Ä–¥–µ—Ä–µ"""
        if not hasattr(self, 'active_orders'):
            self.active_orders = {}
        
        order_id = order_result.get('order_id') or order_result.get('id')
        if order_id:
            self.active_orders[order_id] = {
                'symbol': signal.symbol,
                'side': signal.side_str,
                'action': signal.action_str,
                'size': order_result.get('amount'),
                'price': signal.price,
                'stop_loss': signal.stop_loss,
                'take_profit': signal.take_profit,
                'timestamp': datetime.utcnow(),
                'strategy': signal.strategy,
                'confidence': signal.confidence
            }
        
    async def _execute_real_trade(self, symbol: str, signal: str, position_size: float, 
                                 price: float, trade_data: Dict[str, Any]) -> bool:
        """
        –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ä–µ–∞–ª—å–Ω–æ–π —Ç–æ—Ä–≥–æ–≤–æ–π –æ–ø–µ—Ä–∞—Ü–∏–∏ –Ω–∞ –±–∏—Ä–∂–µ
        
        Args:
            symbol: –¢–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞
            signal: –¢–∏–ø —Å–∏–≥–Ω–∞–ª–∞ (BUY/SELL)
            position_size: –†–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏
            price: –¶–µ–Ω–∞ –≤—Ö–æ–¥–∞
            trade_data: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å–¥–µ–ª–∫–∏
            
        Returns:
            bool: True –µ—Å–ª–∏ —Å–¥–µ–ª–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ
        """
        try:
            logger.info(f"üí∏ –í–´–ü–û–õ–ù–ï–ù–ò–ï –†–ï–ê–õ–¨–ù–û–ô –°–î–ï–õ–ö–ò: {symbol} {signal}")
            logger.info(f"üí∞ –†–µ–∂–∏–º: {'TESTNET' if getattr(config, 'TESTNET', True) else 'LIVE'}")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –µ—Å—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Å–ø–æ—Å–æ–± –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è
            if not any([
                hasattr(self, 'execution_engine') and self.execution_engine,
                hasattr(self, 'exchange_client') and self.exchange_client,
                hasattr(self, 'enhanced_exchange_client') and self.enhanced_exchange_client
            ]):
                logger.error("‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–ø–æ—Å–æ–±–æ–≤ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è —Å–¥–µ–ª–∫–∏")
                return False
            
            logger.info(f"üìä –ü–æ–ø—ã—Ç–∫–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç—å —Ä–µ–∞–ª—å–Ω—ã–π –æ—Ä–¥–µ—Ä: {symbol} {signal} —Ä–∞–∑–º–µ—Ä={position_size}")
            
            # –°–ø–æ—Å–æ–± 1: –ß–µ—Ä–µ–∑ OrderExecutionEngine (–ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω—ã–π)
            if hasattr(self, 'execution_engine') and self.execution_engine and hasattr(self.execution_engine, 'execute_signal'):
                try:
                    logger.debug("üì° –ò—Å–ø–æ–ª—å–∑—É–µ–º execution_engine...")
                    
                    # –°–æ–∑–¥–∞–µ–º —Å–∏–≥–Ω–∞–ª –¥–ª—è execution engine
                    from ..common.types import UnifiedTradingSignal as TradingSignal
                    trading_signal = TradingSignal(
                        symbol=symbol,
                        action=signal.upper(),
                        confidence=trade_data.get('confidence', 0.6),
                        price=price,
                        stop_loss=trade_data.get('stop_loss'),
                        take_profit=trade_data.get('take_profit'),
                        strategy=trade_data.get('strategy', 'unknown')
                    )
                    
                    # –í—ã–ø–æ–ª–Ω—è–µ–º —á–µ—Ä–µ–∑ execution engine
                    result = await self.execution_engine.execute_signal(
                        signal=trading_signal,
                        strategy_name=trade_data.get('strategy', 'multi_indicator'),
                        market_conditions=trade_data.get('market_conditions', {})
                    )
                    
                    if result and result.status.value == 'completed':
                        logger.info(f"‚úÖ –û—Ä–¥–µ—Ä –≤—ã–ø–æ–ª–Ω–µ–Ω —á–µ—Ä–µ–∑ execution_engine: {result.order_id}")
                        return True
                    else:
                        logger.warning(f"‚ö†Ô∏è Execution_engine –≤–µ—Ä–Ω—É–ª —Å—Ç–∞—Ç—É—Å: {result.status.value if result else 'None'}")
                        
                except Exception as e:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ execution_engine: {e}")
            
            # –°–ø–æ—Å–æ–± 2: –ß–µ—Ä–µ–∑ exchange_client –Ω–∞–ø—Ä—è–º—É—é
            if hasattr(self, 'exchange_client') and self.exchange_client and hasattr(self.exchange_client, 'place_order'):
                try:
                    logger.debug("üì° –ò—Å–ø–æ–ª—å–∑—É–µ–º exchange_client...")
                    
                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º place_order –∏–∑ unified_exchange
                    order = await self.exchange_client.place_order(
                        symbol=symbol,
                        side=signal.lower(),
                        amount=position_size,
                        price=price if not getattr(config, 'USE_MARKET_ORDERS', True) else None,
                        order_type='market' if getattr(config, 'USE_MARKET_ORDERS', True) else 'limit'
                    )
                    
                    if order and 'error' not in order:
                        logger.info(f"‚úÖ –û—Ä–¥–µ—Ä –≤—ã–ø–æ–ª–Ω–µ–Ω —á–µ—Ä–µ–∑ exchange_client: {order.get('id')}")
                        
                        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º SL/TP –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                        if trade_data.get('stop_loss') or trade_data.get('take_profit'):
                            await self._set_position_sl_tp(
                                symbol, 
                                trade_data.get('stop_loss'), 
                                trade_data.get('take_profit')
                            )
                        
                        return True
                    else:
                        logger.warning(f"‚ö†Ô∏è Exchange_client –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É: {order.get('error') if order else 'None'}")
                        
                except Exception as e:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ exchange_client: {e}")
            
            # –°–ø–æ—Å–æ–± 3: –ß–µ—Ä–µ–∑ enhanced exchange
            if hasattr(self, 'enhanced_exchange_client') and self.enhanced_exchange_client:
                try:
                    logger.debug("üì° –ò—Å–ø–æ–ª—å–∑—É–µ–º enhanced_exchange_client...")
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –º–µ—Ç–æ–¥–∞
                    if hasattr(self.enhanced_exchange_client, 'v5_client') and self.enhanced_exchange_client.v5_client:
                        # –ò—Å–ø–æ–ª—å–∑—É–µ–º V5 API
                        order_result = await self.enhanced_exchange_client.v5_client.place_order(
                            category='linear',  # –¥–ª—è USDT perpetual
                            symbol=symbol,
                            side='Buy' if signal.upper() == 'BUY' else 'Sell',
                            orderType='Market' if getattr(config, 'USE_MARKET_ORDERS', True) else 'Limit',
                            qty=str(position_size),
                            price=str(price) if not getattr(config, 'USE_MARKET_ORDERS', True) else None,
                            stopLoss=str(trade_data.get('stop_loss')) if trade_data.get('stop_loss') else None,
                            takeProfit=str(trade_data.get('take_profit')) if trade_data.get('take_profit') else None
                        )
                    elif hasattr(self.enhanced_exchange_client, 'place_order'):
                        # Fallback –Ω–∞ –æ–±—ã—á–Ω—ã–π –º–µ—Ç–æ–¥
                        order_result = await self.enhanced_exchange_client.place_order(
                            symbol=symbol,
                            side=signal.lower(),
                            amount=position_size,
                            price=price if not getattr(config, 'USE_MARKET_ORDERS', True) else None,
                            order_type='market' if getattr(config, 'USE_MARKET_ORDERS', True) else 'limit'
                        )
                    else:
                        logger.error("‚ùå Enhanced exchange –Ω–µ –∏–º–µ–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–µ–≥–æ –º–µ—Ç–æ–¥–∞ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –æ—Ä–¥–µ—Ä–∞")
                        return False
                    
                    if order_result and (order_result.get('retCode') == 0 or order_result.get('success')):
                        logger.info(f"‚úÖ –û—Ä–¥–µ—Ä –≤—ã–ø–æ–ª–Ω–µ–Ω —á–µ—Ä–µ–∑ enhanced_exchange: {order_result.get('result', {}).get('orderId', 'unknown')}")
                        return True
                    else:
                        logger.warning(f"‚ö†Ô∏è Enhanced_exchange –≤–µ—Ä–Ω—É–ª: {order_result}")
                        
                except Exception as e:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ enhanced_exchange: {e}")
            
            logger.error("‚ùå –í—Å–µ —Å–ø–æ—Å–æ–±—ã –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Å–¥–µ–ª–∫–∏ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–∏")
            return False
            
        except Exception as e:
            logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Å–¥–µ–ª–∫–∏: {e}")
            logger.error(traceback.format_exc())
            return False
    
    async def _set_position_sl_tp(self, symbol: str, stop_loss: float = None, take_profit: float = None):
        """–£—Å—Ç–∞–Ω–æ–≤–∫–∞ SL/TP –¥–ª—è –ø–æ–∑–∏—Ü–∏–∏"""
        try:
            logger.info(f"üìä –£—Å—Ç–∞–Ω–æ–≤–∫–∞ SL/TP –¥–ª—è {symbol}: SL={stop_loss}, TP={take_profit}")
            
            # –ü–æ–ø—ã—Ç–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —á–µ—Ä–µ–∑ enhanced client
            if hasattr(self, 'enhanced_exchange_client') and self.enhanced_exchange_client:
                if hasattr(self.enhanced_exchange_client, 'set_position_sl_tp'):
                    result = await self.enhanced_exchange_client.set_position_sl_tp(
                        symbol=symbol,
                        stop_loss=stop_loss,
                        take_profit=take_profit
                    )
                    if result:
                        logger.info(f"‚úÖ SL/TP —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –¥–ª—è {symbol}")
                        return True
            
            # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥—Ä—É–≥–∏–µ —Å–ø–æ—Å–æ–±—ã —É—Å—Ç–∞–Ω–æ–≤–∫–∏ SL/TP
            logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å SL/TP –¥–ª—è {symbol}")
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ SL/TP: {e}")
    
    async def _save_trade_to_db(self, symbol: str, trade_data: dict, success: bool):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–¥–µ–ª–∫–µ –≤ –ë–î"""
        try:
            # –ó–¥–µ—Å—å –±—É–¥–µ—Ç –∫–æ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ –ë–î
            logger.debug(f"üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–¥–µ–ª–∫–∏ {symbol} –≤ –ë–î (success={success})")
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ –ë–î: {e}")
    
    async def _send_trade_notification(self, symbol: str, signal: str, size: float, price: float):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Å–¥–µ–ª–∫–µ"""
        try:
            if hasattr(self, 'notifier') and self.notifier:
                message = f"üéØ –í—ã–ø–æ–ª–Ω–µ–Ω–∞ —Å–¥–µ–ª–∫–∞:\n{symbol} {signal}\n–†–∞–∑–º–µ—Ä: {size}\n–¶–µ–Ω–∞: ${price:.4f}"
                await self.notifier.send_message(message)
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
    
    def _prepare_market_data(self, symbol: str):
        """–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Ä—ã–Ω–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞"""
        try:
            if symbol not in self.candle_cache or len(self.candle_cache[symbol]) < 20:
                return None
            
            candles = list(self.candle_cache[symbol])
            
            return {
                'open': [c['open'] for c in candles],
                'high': [c['high'] for c in candles],
                'low': [c['low'] for c in candles],
                'close': [c['close'] for c in candles],
                'volume': [c['volume'] for c in candles],
                'timestamp': [c['timestamp'] for c in candles]
            }
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö {symbol}: {e}")
            return None
    
    def _calculate_position_size(self, symbol: str, price: float) -> float:
        """
        –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–∏—Å–∫-–º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç–∞
        
        Args:
            symbol: –¢–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞
            price: –¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞ –∞–∫—Ç–∏–≤–∞
            
        Returns:
            float: –†–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ –≤ –±–∞–∑–æ–≤–æ–π –≤–∞–ª—é—Ç–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä, BTC –¥–ª—è BTCUSDT)
        """
        try:
            # –ü–æ–ª—É—á–∞–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–π –±–∞–ª–∞–Ω—Å
            available_balance = getattr(self, 'available_balance', 10000)
            
            # –ï—Å–ª–∏ –µ—Å—Ç—å enhanced_exchange_client, –ø–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å
            if hasattr(self, 'enhanced_exchange_client') and self.enhanced_exchange_client:
                try:
                    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è —Ä–∞–±–æ—Ç–∞ —Å –±–∞–ª–∞–Ω—Å–æ–º
                    if hasattr(self.enhanced_exchange_client, 'get_balance'):
                        balance_info = self.enhanced_exchange_client.get_balance()
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∫–æ—Ä—É—Ç–∏–Ω–æ–π
                        import inspect
                        if inspect.iscoroutine(balance_info):
                            # –ï—Å–ª–∏ —ç—Ç–æ –∫–æ—Ä—É—Ç–∏–Ω–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –±–∞–ª–∞–Ω—Å
                            logger.debug("get_balance –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ—Ä—É—Ç–∏–Ω—É, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –±–∞–ª–∞–Ω—Å")
                        elif balance_info and isinstance(balance_info, dict) and 'USDT' in balance_info:
                            available_balance = float(balance_info['USDT'].get('free', available_balance))
                            logger.debug(f"–ü–æ–ª—É—á–µ–Ω –±–∞–ª–∞–Ω—Å –∏–∑ enhanced_exchange_client: ${available_balance:.2f}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –±–∞–ª–∞–Ω—Å: {e}")
            
            # –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ä–∏—Å–∫-–º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç–∞
            risk_per_trade = getattr(config, 'RISK_PER_TRADE_PERCENT', 1.5) / 100
            max_position_percent = getattr(config, 'MAX_POSITION_SIZE_PERCENT', 10) / 100
            
            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∏—Å–∫ –≤ –¥–æ–ª–ª–∞—Ä–∞—Ö
            risk_amount = available_balance * risk_per_trade
            
            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ –≤ –¥–æ–ª–ª–∞—Ä–∞—Ö
            max_position_value = available_balance * max_position_percent
            
            # –ü–æ–ª—É—á–∞–µ–º –ø—Ä–æ—Ü–µ–Ω—Ç —Å—Ç–æ–ø-–ª–æ—Å—Å–∞
            stop_loss_percent = getattr(config, 'STOP_LOSS_PERCENT', 3.0) / 100
            
            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–∏—Å–∫–∞
            # –†–∞–∑–º–µ—Ä = –†–∏—Å–∫ / (–¶–µ–Ω–∞ * –ü—Ä–æ—Ü–µ–Ω—Ç_—Å—Ç–æ–ø_–ª–æ—Å—Å–∞)
            position_size_by_risk = risk_amount / (price * stop_loss_percent)
            
            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ—Ü–µ–Ω—Ç–∞
            position_size_by_max = max_position_value / price
            
            # –ë–µ—Ä–µ–º –º–µ–Ω—å—à–∏–π —Ä–∞–∑–º–µ—Ä –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
            position_size = min(position_size_by_risk, position_size_by_max)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –¥–ª—è Bybit
            min_order_size = self._get_min_order_size(symbol)
            if position_size < min_order_size:
                logger.warning(f"‚ö†Ô∏è –†–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ {position_size:.4f} –º–µ–Ω—å—à–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ {min_order_size}")
                return 0.0
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏–π
            current_positions = len(getattr(self, 'positions', {}))
            max_positions = getattr(config, 'MAX_POSITIONS', 15)
            
            if current_positions >= max_positions:
                logger.warning(f"‚ö†Ô∏è –î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç –ø–æ–∑–∏—Ü–∏–π: {current_positions}/{max_positions}")
                return 0.0
            
            # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º —Ä–∞–∑–º–µ—Ä —Å —É—á–µ—Ç–æ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –ø–æ–∑–∏—Ü–∏–π
            # –ß–µ–º –±–æ–ª—å—à–µ –ø–æ–∑–∏—Ü–∏–π, —Ç–µ–º –º–µ–Ω—å—à–µ —Ä–∞–∑–º–µ—Ä –Ω–æ–≤–æ–π
            position_adjustment = 1.0 - (current_positions / max_positions * 0.5)
            position_size *= position_adjustment
            
            # –û–∫—Ä—É–≥–ª—è–µ–º –¥–æ –Ω—É–∂–Ω–æ–π —Ç–æ—á–Ω–æ—Å—Ç–∏
            position_size = self._round_to_precision(position_size, symbol)
            
            logger.debug(f"üí∞ –†–∞—Å—á–µ—Ç –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è {symbol}:")
            logger.debug(f"   –ë–∞–ª–∞–Ω—Å: ${available_balance:.2f}")
            logger.debug(f"   –†–∏—Å–∫ –Ω–∞ —Å–¥–µ–ª–∫—É: ${risk_amount:.2f} ({risk_per_trade*100:.1f}%)")
            logger.debug(f"   –†–∞–∑–º–µ—Ä –ø–æ —Ä–∏—Å–∫—É: {position_size_by_risk:.4f}")
            logger.debug(f"   –†–∞–∑–º–µ—Ä –ø–æ –º–∞–∫—Å–∏–º—É–º—É: {position_size_by_max:.4f}")
            logger.debug(f"   –ò—Ç–æ–≥–æ–≤—ã–π —Ä–∞–∑–º–µ—Ä: {position_size:.4f}")
            
            return position_size
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ —Ä–∞–∑–º–µ—Ä–∞ –ø–æ–∑–∏—Ü–∏–∏: {e}")
            import traceback
            traceback.print_exc()
            return 0.0
    
    def _get_min_order_size(self, symbol: str) -> float:
        """
        –ü–æ–ª—É—á–∞–µ—Ç –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –æ—Ä–¥–µ—Ä–∞ –¥–ª—è —Å–∏–º–≤–æ–ª–∞
        
        Args:
            symbol: –¢–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞
            
        Returns:
            float: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –æ—Ä–¥–µ—Ä–∞
        """
        # –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã –¥–ª—è –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö –ø–∞—Ä
        min_sizes = {
            'BTCUSDT': 0.001,
            'ETHUSDT': 0.01,
            'BNBUSDT': 0.01,
            'SOLUSDT': 0.1,
            'ADAUSDT': 10,
            'DOTUSDT': 1,
            'MATICUSDT': 10,
            'AVAXUSDT': 0.1,
            'LINKUSDT': 0.1,
            'ATOMUSDT': 0.1
        }
        
        # –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å –∏–∑ –±–∏—Ä–∂–∏
        if hasattr(self, 'exchange_client') and self.exchange_client:
            try:
                markets = self.exchange_client.exchange.markets
                if markets and symbol in markets:
                    market = markets[symbol]
                    if 'limits' in market and 'amount' in market['limits']:
                        return market['limits']['amount']['min']
            except Exception as e:
                logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ª–∏–º–∏—Ç—ã —Å –±–∏—Ä–∂–∏: {e}")
        
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
        return min_sizes.get(symbol, 0.001)
    
    def _round_to_precision(self, value: float, symbol: str) -> float:
        """
        –û–∫—Ä—É–≥–ª—è–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –¥–æ –Ω—É–∂–Ω–æ–π —Ç–æ—á–Ω–æ—Å—Ç–∏ –¥–ª—è —Å–∏–º–≤–æ–ª–∞
        
        Args:
            value: –ó–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –æ–∫—Ä—É–≥–ª–µ–Ω–∏—è
            symbol: –¢–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞
            
        Returns:
            float: –û–∫—Ä—É–≥–ª–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
        """
        # –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å –¥–ª—è –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö –ø–∞—Ä
        precision = {
            'BTCUSDT': 3,
            'ETHUSDT': 3,
            'BNBUSDT': 2,
            'SOLUSDT': 1,
            'ADAUSDT': 0,
            'DOTUSDT': 1,
            'MATICUSDT': 0,
            'AVAXUSDT': 1,
            'LINKUSDT': 1,
            'ATOMUSDT': 1
        }
        
        # –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å –∏–∑ –±–∏—Ä–∂–∏
        if hasattr(self, 'exchange_client') and self.exchange_client:
            try:
                markets = self.exchange_client.exchange.markets
                if markets and symbol in markets:
                    market = markets[symbol]
                    if 'precision' in market and 'amount' in market['precision']:
                        decimals = market['precision']['amount']
                        return round(value, decimals)
            except Exception as e:
                logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ç–æ—á–Ω–æ—Å—Ç—å —Å –±–∏—Ä–∂–∏: {e}")
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é —Ç–æ—á–Ω–æ—Å—Ç—å
        decimals = precision.get(symbol, 3)
        return round(value, decimals)
    
    def _calculate_stop_loss(self, entry_price: float, side: str) -> float:
        """–†–∞—Å—á–µ—Ç —Å—Ç–æ–ø-–ª–æ—Å—Å–∞"""
        try:
            sl_percent = getattr(config, 'STOP_LOSS_PERCENT', 2.0) / 100
            
            if side == 'BUY':
                return entry_price * (1 - sl_percent)
            else:  # SELL
                return entry_price * (1 + sl_percent)
                
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ —Å—Ç–æ–ø-–ª–æ—Å—Å–∞: {e}")
            return entry_price * 0.98 if side == 'BUY' else entry_price * 1.02
    
    def _calculate_take_profit(self, entry_price: float, side: str) -> float:
        """–†–∞—Å—á–µ—Ç —Ç–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç–∞"""
        try:
            tp_percent = getattr(config, 'TAKE_PROFIT_PERCENT', 4.0) / 100
            
            if side == 'BUY':
                return entry_price * (1 + tp_percent)
            else:  # SELL
                return entry_price * (1 - tp_percent)
                
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ —Ç–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç–∞: {e}")
            return entry_price * 1.04 if side == 'BUY' else entry_price * 0.96
            
    
    
    async def start(self) -> Tuple[bool, str]:
        """–ó–∞–ø—É—Å–∫ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –±–æ—Ç–∞ - –ü–û–õ–ù–ê–Ø –í–ï–†–°–ò–Ø"""
        if self.status == BotStatus.RUNNING:
            return False, "–ë–æ—Ç —É–∂–µ –∑–∞–ø—É—â–µ–Ω"
        
        try:
            logger.info("üöÄ –ó–∞–ø—É—Å–∫ –ü–û–õ–ù–û–¶–ï–ù–ù–û–ì–û —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –±–æ—Ç–∞...")
            self.status = BotStatus.STARTING
            
            # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–∏–≥–Ω–∞–ª–æ–≤
            self._setup_signal_handlers()
            
            # ‚úÖ –í–´–ó–´–í–ê–ï–ú –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Æ –¢–û–õ–¨–ö–û –û–î–ò–ù –†–ê–ó
            if not self._initialization_completed:
                logger.info("üîß –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤...")
                init_success = await self._initialize_all_components()
                if not init_success:
                    self.status = BotStatus.ERROR
                    return False, "–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤"
                self._initialization_completed = True
            
            # 2. –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è
            logger.info("‚öôÔ∏è –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏...")
            config_valid = await self._validate_configuration()
            if not config_valid:
                self.status = BotStatus.ERROR
                return False, "–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏"
            
            # 3. –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–∏—Ä–∂–µ
            logger.info("üì° –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–∏—Ä–∂–µ...")
            exchange_connected = await self._connect_exchange()
            if not exchange_connected:
                self.status = BotStatus.ERROR
                return False, "–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∏—Ä–∂–µ"
                
            # 4. –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –∞–∫–∫–∞—É–Ω—Ç–µ
            logger.info("üí∞ –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –∞–∫–∫–∞—É–Ω—Ç–µ...")
            await self._display_account_info()
            
            # 4. –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä
            logger.info("üí∞ –ü–æ–∏—Å–∫ —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä...")
            pairs_discovered = await self._discover_all_trading_pairs()
            if not pairs_discovered:
                logger.warning("‚ö†Ô∏è –û—à–∏–±–∫–∞ –∞–≤—Ç–æ–ø–æ–∏—Å–∫–∞ –ø–∞—Ä, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ")
                self.active_pairs = self.trading_pairs[:config.MAX_TRADING_PAIRS]
            
            # 5. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
            logger.info("üéØ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–π...")
            await self._initialize_strategies()
            
            # 6. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ML –º–æ–¥–µ–ª–µ–π
            if config.ENABLE_MACHINE_LEARNING:
                logger.info("üß† –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ML –º–æ–¥–µ–ª–µ–π...")
                await self._init_ml_system()
            
            # 7. –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö
            logger.info("üìä –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö...")
            await self._load_historical_data()
            
            # 8. –ê–Ω–∞–ª–∏–∑ —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Ä—ã–Ω–∫–∞
            logger.info("üåê –ê–Ω–∞–ª–∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Ä—ã–Ω–∫–∞...")
            await self._perform_initial_market_analysis()
            
            # 9. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
            logger.info("üëÄ –ó–∞–ø—É—Å–∫ —Å–∏—Å—Ç–µ–º—ã –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞...")
            await self._setup_monitoring_system()
            
            # 10. –ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö —Ç–æ—Ä–≥–æ–≤—ã—Ö —Ü–∏–∫–ª–æ–≤
            logger.info("üîÑ –ó–∞–ø—É—Å–∫ —Ç–æ—Ä–≥–æ–≤—ã—Ö —Ü–∏–∫–ª–æ–≤...")
            await self._start_all_trading_loops()
            
            # 11. –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è —Å–∏—Å—Ç–µ–º—ã
            health_status = await self._perform_health_check()
            if not health_status['overall_healthy']:
                logger.warning("‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –ø—Ä–æ–±–ª–µ–º—ã –≤ —Å–∏—Å—Ç–µ–º–µ, –Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ä–∞–±–æ—Ç—É")
            
            # 12. –ó–∞–ø—É—Å–∫ WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
            if config.ENABLE_WEBSOCKET:
                logger.info("üåê –ó–∞–ø—É—Å–∫ WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π...")
                await self._start_websocket_connections()
            
            # 13. –û—Ç–ø—Ä–∞–≤–∫–∞ —Å—Ç–∞—Ä—Ç–æ–≤–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
            await self._send_startup_notification()
            
            self.status = BotStatus.RUNNING
            self.start_time = datetime.utcnow()
            self._stop_event.clear()
            self._pause_event.set()  # –ù–µ –Ω–∞ –ø–∞—É–∑–µ
            
            startup_time = (datetime.utcnow() - self.start_time).total_seconds()
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º –≥–ª–∞–≤–Ω—ã–π —Ç–æ—Ä–≥–æ–≤—ã–π —Ü–∏–∫–ª
            try:
                await self._main_trading_loop()
            except asyncio.CancelledError:
                logger.info("üõë –ì–ª–∞–≤–Ω—ã–π —Ç–æ—Ä–≥–æ–≤—ã–π —Ü–∏–∫–ª –æ—Ç–º–µ–Ω–µ–Ω")
            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ –≥–ª–∞–≤–Ω–æ–º —Ç–æ—Ä–≥–æ–≤–æ–º —Ü–∏–∫–ª–µ: {e}")
                self.status = BotStatus.ERROR
                raise
            
            logger.info("‚úÖ –ü–û–õ–ù–û–¶–ï–ù–ù–´–ô —Ç–æ—Ä–≥–æ–≤—ã–π –±–æ—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω!")
            logger.info(f"üìä –ê–∫—Ç–∏–≤–Ω—ã—Ö –ø–∞—Ä: {len(self.active_pairs)}")
            logger.info(f"üéØ –°—Ç—Ä–∞—Ç–µ–≥–∏–π: {len(self.available_strategies)}")
            logger.info(f"üß† ML –º–æ–¥–µ–ª–µ–π: {len(self.ml_models)}")
            logger.info(f"‚è±Ô∏è –í—Ä–µ–º—è –∑–∞–ø—É—Å–∫–∞: {startup_time:.2f}—Å")
            
            # –õ–æ–≥–∏—Ä—É–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            await self._log_startup_statistics()
            
            return True, f"–ë–æ—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω –∑–∞ {startup_time:.1f}—Å"
            
        except Exception as e:
            self.status = BotStatus.ERROR
            error_msg = f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞: {str(e)}"
            logger.error(error_msg)
            logger.error(traceback.format_exc())
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
            await self._send_error_notification(error_msg)
            
            return False, error_msg
            
            
    
    
    async def stop(self) -> Tuple[bool, str]:
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –±–æ—Ç–∞ - –ü–û–õ–ù–ê–Ø –í–ï–†–°–ò–Ø"""
        if self.status == BotStatus.STOPPED:
            return False, "–ë–æ—Ç —É–∂–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"
        
        try:
            logger.info("üõë –û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –±–æ—Ç–∞...")
            old_status = self.status
            self.status = BotStatus.STOPPING
            
            # 1. –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ–±—ã—Ç–∏—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
            self._stop_event.set()
            
            # 2. –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            logger.info("üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è...")
            await self._save_current_state()
            
            # 3. –ó–∞–∫—Ä—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏–∏ (–µ—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ)
            if config.CLOSE_POSITIONS_ON_STOP:
                logger.info("üìä –ó–∞–∫—Ä—ã—Ç–∏–µ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏–π...")
                await self._close_all_positions_safely()
            
            # 4. –û—Ç–º–µ–Ω—è–µ–º –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –æ—Ä–¥–µ—Ä–∞
            logger.info("‚ùå –û—Ç–º–µ–Ω–∞ –∞–∫—Ç–∏–≤–Ω—ã—Ö –æ—Ä–¥–µ—Ä–æ–≤...")
            await self._cancel_all_orders()
            
            # 5. –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ –∑–∞–¥–∞—á–∏
            logger.info("üîÑ –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–¥–∞—á...")
            await self._stop_all_tasks()
            
            # 6. –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
            if hasattr(self, 'websocket_connections'):
                logger.info("üåê –ó–∞–∫—Ä—ã—Ç–∏–µ WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π...")
                await self._close_websocket_connections()
            
            # 7. –ó–∞–≤–µ—Ä—à–∞–µ–º –æ–±—É—á–µ–Ω–∏–µ ML –º–æ–¥–µ–ª–µ–π
            if config.ENABLE_MACHINE_LEARNING:
                logger.info("üß† –û—Å—Ç–∞–Ω–æ–≤–∫–∞ ML —Å–∏—Å—Ç–µ–º—ã...")
                await self._stop_ml_system()
            
            # 8. –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
            logger.info("üì§ –≠–∫—Å–ø–æ—Ä—Ç —Ñ–∏–Ω–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö...")
            await self._export_final_data()
            
            # 9. –û—Ç–∫–ª—é—á–∞–µ–º—Å—è –æ—Ç –±–∏—Ä–∂–∏
            logger.info("üì° –û—Ç–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç –±–∏—Ä–∂–∏...")
            await self._disconnect_exchange()
            
            # 10. –ó–∞–∫—Ä—ã–≤–∞–µ–º –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
            logger.info("üóÑÔ∏è –ó–∞–∫—Ä—ã—Ç–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π —Å –ë–î...")
            await self._close_database_connections()
            
            # 11. –û—á–∏—â–∞–µ–º –∫—ç—à–∏
            logger.info("üßπ –û—á–∏—Å—Ç–∫–∞ –∫—ç—à–µ–π...")
            await self._cleanup_caches()
            
            # 12. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–∏–Ω–∞–ª—å–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
            await self._send_shutdown_notification(old_status)
            
            self.status = BotStatus.STOPPED
            self.stop_time = datetime.utcnow()
            
            if self.start_time:
                uptime = (self.stop_time - self.start_time).total_seconds()
                logger.info(f"‚è±Ô∏è –í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã: {uptime:.1f}—Å ({uptime/3600:.1f}—á)")
            
            logger.info("‚úÖ –¢–æ—Ä–≥–æ–≤—ã–π –±–æ—Ç —É—Å–ø–µ—à–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
            return True, "–ë–æ—Ç —É—Å–ø–µ—à–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"
            
        except Exception as e:
            error_msg = f"–û—à–∏–±–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –±–æ—Ç–∞: {str(e)}"
            logger.error(error_msg)
            logger.error(traceback.format_exc())
            return False, error_msg
    
    async def pause(self) -> Tuple[bool, str]:
        """–ü—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –±–æ—Ç–∞"""
        if self.status != BotStatus.RUNNING:
            return False, "–ë–æ—Ç –Ω–µ –∑–∞–ø—É—â–µ–Ω"
        
        try:
            logger.info("‚è∏Ô∏è –ü—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –±–æ—Ç–∞...")
            self.status = BotStatus.PAUSED
            self.pause_time = datetime.utcnow()
            self._pause_event.clear()  # –°—Ç–∞–≤–∏–º –Ω–∞ –ø–∞—É–∑—É
            
            # –û—Ç–º–µ–Ω—è–µ–º –≤—Å–µ –Ω–æ–≤—ã–µ –æ—Ä–¥–µ—Ä–∞, –Ω–æ –æ—Å—Ç–∞–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –ø–æ–∑–∏—Ü–∏–∏
            await self._cancel_pending_orders()
            
            await self._send_pause_notification()
            
            logger.info("‚úÖ –¢–æ—Ä–≥–æ–≤—ã–π –±–æ—Ç –ø—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
            return True, "–ë–æ—Ç –ø—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"
            
        except Exception as e:
            error_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–∫–∏: {str(e)}"
            logger.error(error_msg)
            return False, error_msg
    
    async def resume(self) -> Tuple[bool, str]:
        """–í–æ–∑–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –±–æ—Ç–∞"""
        if self.status != BotStatus.PAUSED:
            return False, "–ë–æ—Ç –Ω–µ –Ω–∞ –ø–∞—É–∑–µ"
        
        try:
            logger.info("‚ñ∂Ô∏è –í–æ–∑–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –±–æ—Ç–∞...")
            self.status = BotStatus.RUNNING
            self._pause_event.set()  # –°–Ω–∏–º–∞–µ–º —Å –ø–∞—É–∑—ã
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Ä—ã–Ω–æ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
            await self._refresh_market_data()
            
            await self._send_resume_notification()
            
            if self.pause_time:
                pause_duration = (datetime.utcnow() - self.pause_time).total_seconds()
                logger.info(f"‚úÖ –†–∞–±–æ—Ç–∞ –≤–æ–∑–æ–±–Ω–æ–≤–ª–µ–Ω–∞ –ø–æ—Å–ª–µ –ø–∞—É–∑—ã {pause_duration:.1f}—Å")
            
            return True, "–†–∞–±–æ—Ç–∞ –≤–æ–∑–æ–±–Ω–æ–≤–ª–µ–Ω–∞"
            
        except Exception as e:
            error_msg = f"–û—à–∏–±–∫–∞ –≤–æ–∑–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: {str(e)}"
            logger.error(error_msg)
            return False, error_msg
    
    async def emergency_stop(self) -> Tuple[bool, str]:
        """–≠–∫—Å—Ç—Ä–µ–Ω–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å –∑–∞–∫—Ä—ã—Ç–∏–µ–º –≤—Å–µ—Ö –ø–æ–∑–∏—Ü–∏–π"""
        try:
            logger.critical("üö® –≠–ö–°–¢–†–ï–ù–ù–ê–Ø –û–°–¢–ê–ù–û–í–ö–ê –ê–ö–¢–ò–í–ò–†–û–í–ê–ù–ê!")
            self.status = BotStatus.EMERGENCY_STOP
            self.emergency_stop_triggered = True
            
            # –ú–≥–Ω–æ–≤–µ–Ω–Ω–æ –∑–∞–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ –ø–æ–∑–∏—Ü–∏–∏
            await self._emergency_close_all_positions()
            
            # –û—Ç–º–µ–Ω—è–µ–º –≤—Å–µ –æ—Ä–¥–µ—Ä–∞
            await self._cancel_all_orders()
            
            # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ —Ü–∏–∫–ª—ã
            self._stop_event.set()
            
            await self._send_emergency_notification()
            
            logger.critical("üö® –≠–∫—Å—Ç—Ä–µ–Ω–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞")
            return True, "–≠–∫—Å—Ç—Ä–µ–Ω–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞"
            
        except Exception as e:
            error_msg = f"–û—à–∏–±–∫–∞ —ç–∫—Å—Ç—Ä–µ–Ω–Ω–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–∏: {str(e)}"
            logger.critical(error_msg)
            return False, error_msg
    
    def get_status(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–ª–Ω–æ–≥–æ —Å—Ç–∞—Ç—É—Å–∞ –±–æ—Ç–∞ - –†–ê–°–®–ò–†–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø"""
        current_time = datetime.utcnow()
        uptime = None
        
        if self.start_time:
            uptime = (current_time - self.start_time).total_seconds()
        
        # –ë–∞–∑–æ–≤–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
        status_info = {
            # –û—Å–Ω–æ–≤–Ω–æ–π —Å—Ç–∞—Ç—É—Å
            'status': self.status.value,
            'is_running': self.status == BotStatus.RUNNING,
            'is_paused': self.status == BotStatus.PAUSED,
            'start_time': self.start_time.isoformat() if self.start_time else None,
            'stop_time': self.stop_time.isoformat() if self.stop_time else None,
            'pause_time': self.pause_time.isoformat() if self.pause_time else None,
            'uptime_seconds': uptime,
            'cycles_count': self.cycles_count,
            'mode': self.mode,
            
            # –¢–æ—Ä–≥–æ–≤—ã–µ –ø–∞—Ä—ã
            'trading_pairs': {
                'total_pairs': len(self.all_trading_pairs),
                'active_pairs': len(self.active_pairs),
                'inactive_pairs': len(self.inactive_pairs),
                'blacklisted_pairs': len(self.blacklisted_pairs),
                'watchlist_pairs': len(self.watchlist_pairs),
                'trending_pairs': self.trending_pairs[:10],  # –¢–æ–ø-10
                'high_volume_pairs': self.high_volume_pairs[:10]
            },
            
            # –ü–æ–∑–∏—Ü–∏–∏ –∏ —Å–¥–µ–ª–∫–∏
            'trading': {
                'open_positions': len(self.positions),
                'pending_orders': len(self.pending_orders),
                'trades_today': self.trades_today,
                'daily_profit': round(self.daily_profit, 2),
                'weekly_profit': round(self.weekly_profit, 2),
                'monthly_profit': round(self.monthly_profit, 2),
                'opportunities_found': len(self.current_opportunities),
                'missed_opportunities': len(self.missed_opportunities)
            },
            
            # –°—Ç—Ä–∞—Ç–µ–≥–∏–∏
            'strategies': {
                'available_strategies': self.available_strategies,
                'active_strategies': [name for name, perf in self.strategy_performance.items() 
                                   if perf.get('enabled', True)],
                'best_performing_strategy': self._get_best_strategy(),
                'strategy_performance': dict(self.strategy_performance)
            },
            
            # –°–æ—Å—Ç–æ—è–Ω–∏–µ —Ä—ã–Ω–∫–∞
            'market_state': {
                'overall_trend': self.market_state.overall_trend,
                'volatility': self.market_state.volatility,
                'fear_greed_index': self.market_state.fear_greed_index,
                'market_regime': self.market_state.market_regime,
                'risk_level': self.market_state.risk_level.value,
                'btc_dominance': round(self.market_state.dominance_btc, 2),
                'eth_dominance': round(self.market_state.dominance_eth, 2),
                'total_market_cap': self.market_state.market_cap,
                'volume_24h': self.market_state.volume_24h
            },
            
            # –ú–∞—à–∏–Ω–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ
            'machine_learning': {
                'enabled': config.ENABLE_MACHINE_LEARNING,
                'models_loaded': len(self.ml_models),
                'predictions_cached': len(self.ml_predictions),
                'models_performance': dict(self.model_performance),
                'training_queue_size': self.training_queue.qsize() if hasattr(self.training_queue, 'qsize') else 0
            },
            
            # –ê–Ω–∞–ª–∏–∑ –Ω–æ–≤–æ—Å—Ç–µ–π
            'news_analysis': {
                'enabled': config.ENABLE_NEWS_ANALYSIS,
                'news_cached': len(self.news_cache),
                'sentiment_scores': len(self.news_sentiment),
                'social_signals': len(self.social_signals)
            },
            
            # –†–∏—Å–∫-–º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç
            'risk_management': {
                'portfolio_risk': round(self.portfolio_risk * 100, 2),
                'daily_loss': round(self.daily_loss * 100, 2),
                'risk_alerts': len(self.risk_alerts),
                'circuit_breaker_active': self.circuit_breaker_active,
                'correlation_pairs': len(self.correlation_matrix),
                'risk_limits': self.risk_limits
            },
            
            # –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
            'performance': asdict(self.performance_metrics),
            
            # –ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Å–∏—Å—Ç–µ–º—ã
            'components': {
                name: {
                    'status': comp.status.value,
                    'last_heartbeat': comp.last_heartbeat.isoformat() if comp.last_heartbeat else None,
                    'restart_count': comp.restart_count,
                    'is_critical': comp.is_critical
                }
                for name, comp in self.components.items()
            },
            
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
            'statistics': asdict(self.trading_stats),
            
            # –ê–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–¥–∞—á–∏
            'tasks': {
                name: {
                    'running': not task.done() if task else False,
                    'health': self.task_health.get(name, 'unknown')
                }
                for name, task in self.tasks.items()
            },
            
            # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
            'configuration': {
                'max_positions': config.MAX_POSITIONS,
                'max_daily_trades': config.MAX_DAILY_TRADES,
                'max_trading_pairs': config.MAX_TRADING_PAIRS,
                'position_size_percent': config.POSITION_SIZE_PERCENT,
                'stop_loss_percent': config.STOP_LOSS_PERCENT,
                'take_profit_percent': config.TAKE_PROFIT_PERCENT,
                'testnet_mode': config.BYBIT_TESTNET,
                'ml_enabled': config.ENABLE_MACHINE_LEARNING,
                'news_analysis_enabled': config.ENABLE_NEWS_ANALYSIS
            },
            
            # –í—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ—Ç–∫–∏
            'timestamps': {
                'current_time': current_time.isoformat(),
                'last_analysis': getattr(self, 'last_analysis_time', None),
                'last_trade': getattr(self, 'last_trade_time', None),
                'last_health_check': getattr(self, 'last_health_check_time', None)
            }
        }
        
        return status_info
    
    # =================================================================
    # –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ö–û–ú–ü–û–ù–ï–ù–¢–û–í
    # =================================================================
    
    async def _initialize_all_components(self) -> bool:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ —Å–∏—Å—Ç–µ–º—ã"""
        try:
            logger.info("üîß –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ —Å–∏—Å—Ç–µ–º—ã...")
            
            # ‚úÖ –°–ù–ê–ß–ê–õ–ê –ò–ù–ò–¶–ò–ê–õ–ò–ó–ò–†–£–ï–ú EXCHANGE –û–¢–î–ï–õ–¨–ù–û (–í–ù–ï –¶–ò–ö–õ–ê)
            if not self._exchange_initialized:
                logger.info("üîß –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è exchange_client...")
                exchange_success = await self._init_exchange_client()
                if not exchange_success:
                    logger.error("‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å exchange")
                    return False
                self._exchange_initialized = True
                logger.info("‚úÖ exchange_client –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            else:
                logger.info("‚úÖ exchange_client —É–∂–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            
            # ‚úÖ –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ENHANCED EXCHANGE - –î–û–ë–ê–í–õ–ï–ù–û –ó–î–ï–°–¨
            logger.info("üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è enhanced exchange...")
            try:
                await self.initialize_enhanced_exchange()
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Enhanced exchange –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: {e}")
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ—Ä—è–¥–æ–∫ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Å —É—á–µ—Ç–æ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
            initialization_order = [
                ('database', self._init_database, [], True),
                ('config_validator', self._init_config_validator, ['database'], True),
                ('data_collector', self._init_data_collector, [], True),
                ('market_analyzer', self._init_market_analyzer, ['data_collector'], True),
                ('risk_manager', self._init_risk_manager, ['market_analyzer'], True),
                ('portfolio_manager', self._init_portfolio_manager, ['risk_manager'], True),
                ('strategy_factory', self._init_strategy_factory, ['market_analyzer'], True),
                ('trader', self._init_trader, ['exchange_client', 'risk_manager'], True),
                ('execution_engine', self._init_execution_engine, ['exchange_client', 'risk_manager'], False),
                ('notifier', self._init_notifier, [], False),
                ('ml_system', self._init_ml_system, ['data_collector'], False),
                ('news_analyzer', self._init_news_analyzer, [], False),
                ('websocket_manager', self._init_websocket_manager, ['exchange_client'], False),
                ('export_manager', self._init_export_manager, ['database'], False),
                ('health_monitor', self._init_health_monitor, [], False)
            ]
            
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –≤ –ø–æ—Ä—è–¥–∫–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
            for comp_name, init_func, dependencies, is_critical in initialization_order:
                try:
                    # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ —Å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å—é –æ—Ç exchange_client
                    if 'exchange_client' in dependencies and not self._exchange_initialized:
                        logger.warning(f"‚ö†Ô∏è {comp_name} –ø—Ä–æ–ø—É—â–µ–Ω - exchange_client –µ—â–µ –Ω–µ –≥–æ—Ç–æ–≤")
                        continue
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
                    other_deps = [dep for dep in dependencies if dep != 'exchange_client']
                    deps_ready = all(
                        self.components.get(dep, ComponentInfo('', ComponentStatus.NOT_INITIALIZED)).status == ComponentStatus.READY
                        for dep in other_deps
                    )
                    
                    if not deps_ready and other_deps:
                        logger.warning(f"‚ö†Ô∏è –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –¥–ª—è {comp_name} –Ω–µ –≥–æ—Ç–æ–≤—ã: {other_deps}")
                        if is_critical:
                            return False
                        continue
                    
                    # –°–æ–∑–¥–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–µ
                    comp_info = ComponentInfo(
                        name=comp_name,
                        status=ComponentStatus.INITIALIZING,
                        dependencies=dependencies,
                        is_critical=is_critical
                    )
                    self.components[comp_name] = comp_info
                    
                    logger.info(f"üîß –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è {comp_name}...")
                    
                    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
                    result = await init_func()
                    
                    if result:
                        comp_info.status = ComponentStatus.READY
                        comp_info.last_heartbeat = datetime.utcnow()
                        logger.info(f"‚úÖ {comp_name} –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
                    else:
                        comp_info.status = ComponentStatus.FAILED
                        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ {comp_name}")
                        if is_critical:
                            return False
                        
                except Exception as e:
                    logger.error(f"‚ùå –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ {comp_name}: {e}")
                    if comp_name in self.components:
                        self.components[comp_name].status = ComponentStatus.FAILED
                        self.components[comp_name].error = str(e)
                    if is_critical:
                        return False
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
            critical_components = [name for name, comp in self.components.items() if comp.is_critical]
            failed_critical = [name for name in critical_components 
                             if self.components[name].status != ComponentStatus.READY]
            
            if failed_critical:
                logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã: {failed_critical}")
                return False
            
            logger.info(f"‚úÖ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ {len([c for c in self.components.values() if c.status == ComponentStatus.READY])} –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤: {e}")
            return False
    
    async def _init_execution_engine(self) -> bool:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–≤–∏–∂–∫–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è –æ—Ä–¥–µ—Ä–æ–≤"""
        try:
            from ..exchange.execution_engine import OrderExecutionEngine, get_execution_engine
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–∏–Ω–≥–ª—Ç–æ–Ω
            self.execution_engine = get_execution_engine()
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å
            if self.execution_engine:
                logger.info("‚úÖ OrderExecutionEngine –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
                
                # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                self.execution_engine.validation_settings.update({
                    'min_confidence': getattr(self.config, 'MIN_SIGNAL_CONFIDENCE', 0.6),
                    'max_slippage': getattr(self.config, 'MAX_SLIPPAGE_PERCENT', 0.5) / 100,
                    'min_volume_ratio': 0.01,
                    'max_position_correlation': 0.7
                })
                
                return True
            else:
                logger.warning("‚ö†Ô∏è OrderExecutionEngine –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä—è–º–æ–µ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ OrderExecutionEngine: {e}")
            return False
    
    async def _display_account_info(self):
        """–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –∞–∫–∫–∞—É–Ω—Ç–µ –∏ –±–∞–ª–∞–Ω—Å–µ"""
        try:
            logger.info("üí∞ –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –±–∞–ª–∞–Ω—Å–µ –∞–∫–∫–∞—É–Ω—Ç–∞...")
            
            # –ü–æ–ª—É—á–∞–µ–º –±–∞–ª–∞–Ω—Å —á–µ—Ä–µ–∑ enhanced client (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç)
            balance_info = None
            
            if self.enhanced_exchange_client:
                try:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å v5_client —á–µ—Ä–µ–∑ bybit_integration
                    if hasattr(self.enhanced_exchange_client, 'bybit_integration') and \
                       hasattr(self.enhanced_exchange_client.bybit_integration, 'v5_client') and \
                       self.enhanced_exchange_client.bybit_integration.v5_client:
                        # –ü–æ–ª—É—á–∞–µ–º –±–∞–ª–∞–Ω—Å —á–µ—Ä–µ–∑ v5_client
                        balance_info = await self.enhanced_exchange_client.bybit_integration.v5_client.get_wallet_balance()
                        logger.debug("‚úÖ –ë–∞–ª–∞–Ω—Å –ø–æ–ª—É—á–µ–Ω —á–µ—Ä–µ–∑ v5_client")
                    else:
                        logger.warning("‚ö†Ô∏è V5 client –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –≤ enhanced client")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Enhanced client –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: {e}")
            
            # Fallback –∫ –æ–±—ã—á–Ω–æ–º—É –∫–ª–∏–µ–Ω—Ç—É
            if not balance_info and self.exchange_client:
                try:
                    # –ü—Ä–æ–±—É–µ–º —á–µ—Ä–µ–∑ UnifiedExchangeClient
                    if hasattr(self.exchange_client, 'exchange') and self.exchange_client.exchange:
                        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π –º–µ—Ç–æ–¥ get_balance –∏–∑ UnifiedExchangeClient
                        unified_balance = await self.exchange_client.get_balance()
                        
                        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Ñ–æ—Ä–º–∞—Ç –¥–ª—è _process_balance_info
                        if 'error' not in unified_balance:
                            balance_info = {
                                'retCode': 0,
                                'result': {
                                    'list': [{
                                        'accountType': 'UNIFIED',
                                        'totalEquity': str(unified_balance.get('total_usdt', 0)),
                                        'totalAvailableBalance': str(unified_balance.get('free_usdt', 0)),
                                        'totalWalletBalance': str(unified_balance.get('total_usdt', 0)),
                                        'coin': []
                                    }]
                                }
                            }
                            
                            # –î–æ–±–∞–≤–ª—è–µ–º –¥–µ—Ç–∞–ª–∏ –ø–æ –º–æ–Ω–µ—Ç–∞–º
                            for coin, details in unified_balance.get('assets', {}).items():
                                balance_info['result']['list'][0]['coin'].append({
                                    'coin': coin,
                                    'walletBalance': str(details.get('total', 0)),
                                    'availableToWithdraw': str(details.get('free', 0)),
                                    'equity': str(details.get('total', 0))
                                })
                            
                            logger.debug("‚úÖ –ë–∞–ª–∞–Ω—Å –ø–æ–ª—É—á–µ–Ω –∏ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω –∏–∑ UnifiedExchangeClient")
                except Exception as e:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞: {e}")
            
            if balance_info and isinstance(balance_info, dict):
                await self._process_balance_info(balance_info)
            else:
                logger.warning("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –±–∞–ª–∞–Ω—Å–µ")
                
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –∞–∫–∫–∞—É–Ω—Ç–µ: {e}")
            logger.error(traceback.format_exc())
    
    async def _process_balance_info(self, balance_info: dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –±–∞–ª–∞–Ω—Å–µ - –ò–°–ü–†–ê–í–õ–ï–ù–û"""
        try:
            logger.info("üí∞ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
            logger.info("üí∞ –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –¢–û–†–ì–û–í–û–ú –ê–ö–ö–ê–£–ù–¢–ï BYBIT")
            logger.info("üí∞ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
            
            # –§—É–Ω–∫—Ü–∏—è –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –≤ float
            def safe_float(value, default=0.0):
                """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –≤ float"""
                if value is None:
                    return default
                if isinstance(value, (int, float)):
                    return float(value)
                if isinstance(value, str):
                    if value.strip() == '' or value.strip() == '0' or value.strip() == 'null':
                        return default
                    try:
                        return float(value.strip())
                    except (ValueError, AttributeError):
                        return default
                return default
            
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è Bybit Unified Account
            if 'result' in balance_info and balance_info.get('retCode') == 0:
                result = balance_info.get('result', {})
                account_list = result.get('list', [])
                
                if account_list:
                    account = account_list[0]
                    
                    # –û–±—â–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
                    account_type = account.get('accountType', 'UNIFIED')
                    total_equity = safe_float(account.get('totalEquity', 0))
                    total_available = safe_float(account.get('totalAvailableBalance', 0))
                    total_wallet = safe_float(account.get('totalWalletBalance', 0))
                    
                    logger.info(f"üíº –¢–ò–ü –ê–ö–ö–ê–£–ù–¢–ê: {account_type} (–ï–¥–∏–Ω—ã–π —Ç–æ—Ä–≥–æ–≤—ã–π)")
                    logger.info(f"üí∞ –û–±—â–∏–π –±–∞–ª–∞–Ω—Å: ${total_wallet:.2f}")
                    logger.info(f"üìä –û–±—â–∏–π –∫–∞–ø–∏—Ç–∞–ª: ${total_equity:.2f}")
                    logger.info(f"‚úÖ –î–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏: ${total_available:.2f}")
                    
                    # –î–µ—Ç–∞–ª–∏ –ø–æ –º–æ–Ω–µ—Ç–∞–º
                    coins = account.get('coin', [])
                    logger.info("üìä –î–ï–¢–ê–õ–ò–ó–ê–¶–ò–Ø –ü–û –ê–ö–¢–ò–í–ê–ú:")
                    
                    for coin_data in coins:
                        coin_symbol = coin_data.get('coin', '')
                        
                        if coin_symbol == 'USDT':
                            # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –ø–æ–ª—è –±–∞–ª–∞–Ω—Å–∞
                            wallet_balance = safe_float(coin_data.get('walletBalance', 0))
                            equity = safe_float(coin_data.get('equity', 0))
                            
                            # –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ –ø–æ–ª—è –¥–ª—è –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞
                            available_withdraw = safe_float(coin_data.get('availableToWithdraw', 0))
                            available_balance = safe_float(coin_data.get('availableBalance', 0))
                            free_balance = safe_float(coin_data.get('free', 0))
                            
                            # –î–ª—è SPOT –∞–∫–∫–∞—É–Ω—Ç–∞ –º–æ–∂–µ—Ç –±—ã—Ç—å availableToBorrow
                            available_borrow = safe_float(coin_data.get('availableToBorrow', 0))
                            
                            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –±–∞–ª–∞–Ω—Å
                            locked = safe_float(coin_data.get('locked', 0))
                            
                            # ‚úÖ –í–ê–ñ–ù–û: –í Unified Account –≤–µ—Å—å –±–∞–ª–∞–Ω—Å –¥–æ—Å—Ç—É–ø–µ–Ω –µ—Å–ª–∏ –Ω–µ—Ç –ø–æ–∑–∏—Ü–∏–π
                            if available_withdraw == 0 and available_balance == 0 and free_balance == 0:
                                # –ï—Å–ª–∏ –Ω–µ—Ç –ø–æ–∑–∏—Ü–∏–π, –≤–µ—Å—å –±–∞–ª–∞–Ω—Å –¥–æ—Å—Ç—É–ø–µ–Ω
                                available_final = wallet_balance - locked
                            else:
                                # –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∏–∑ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
                                available_final = max(available_withdraw, available_balance, free_balance, available_borrow)
                            
                            logger.info(f"   üí∞ USDT:")
                            logger.info(f"      üìà –ë–∞–ª–∞–Ω—Å: {wallet_balance:.2f}")
                            logger.info(f"      ‚úÖ –î–æ—Å—Ç—É–ø–Ω–æ: {available_final:.2f}")
                            logger.info(f"      üîí –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ: {locked:.2f}")
                            
                            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∑–Ω–∞—á–µ–Ω–∏—è
                            self.balance = wallet_balance
                            self.available_balance = available_final
                            self.locked_balance = locked
                            
                            # –õ–æ–≥–∏—Ä—É–µ–º –æ—Ç–ª–∞–¥–æ—á–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
                            logger.debug(f"üîç USDT –±–∞–ª–∞–Ω—Å –¥–µ—Ç–∞–ª–∏:")
                            logger.debug(f"   walletBalance: {coin_data.get('walletBalance', 'N/A')}")
                            logger.debug(f"   availableToWithdraw: {coin_data.get('availableToWithdraw', 'N/A')}")
                            logger.debug(f"   availableBalance: {coin_data.get('availableBalance', 'N/A')}")
                            logger.debug(f"   free: {coin_data.get('free', 'N/A')}")
                            logger.debug(f"   locked: {coin_data.get('locked', 'N/A')}")
                            logger.debug(f"   equity: {coin_data.get('equity', 'N/A')}")
                    
                    # ‚úÖ –ù–ï –ü–†–ò–ù–£–î–ò–¢–ï–õ–¨–ù–û —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –±–∞–ª–∞–Ω—Å –¥–ª—è TESTNET
                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å –±–∏—Ä–∂–∏!
                    
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è –æ–±—ã—á–Ω–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞ –±–∞–ª–∞–Ω—Å–∞
            elif isinstance(balance_info, dict) and any(key in balance_info for key in ['USDT', 'BTC', 'ETH']):
                logger.info("üè¶ –ë–ê–õ–ê–ù–° –ü–û –ê–ö–¢–ò–í–ê–ú:")
                
                main_currencies = ['USDT', 'BTC', 'ETH', 'BNB']
                
                for currency in main_currencies:
                    if currency in balance_info:
                        balance_data = balance_info[currency]
                        if isinstance(balance_data, dict):
                            free = safe_float(balance_data.get('free', 0))
                            used = safe_float(balance_data.get('used', 0))
                            total = safe_float(balance_data.get('total', 0))
                            
                            if total > 0:
                                logger.info(f"   ü™ô {currency}: {total:.4f} (—Å–≤–æ–±–æ–¥–Ω–æ: {free:.4f})")
                        
                        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º USDT –∫–∞–∫ –æ—Å–Ω–æ–≤–Ω–æ–π –±–∞–ª–∞–Ω—Å
                        if currency == 'USDT' and isinstance(balance_data, dict):
                            self.balance = safe_float(balance_data.get('total', 0))
                            self.available_balance = safe_float(balance_data.get('free', 0))
            
            # ‚úÖ –î–û–ë–ê–í–õ–ï–ù–û: –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∏ —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
            if not hasattr(self, 'balance') or self.balance is None:
                self.balance = 0.0
                logger.warning("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –æ—Å–Ω–æ–≤–Ω–æ–π –±–∞–ª–∞–Ω—Å, —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω 0")
            
            if not hasattr(self, 'available_balance') or self.available_balance is None:
                self.available_balance = 0.0
                logger.warning("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–π –±–∞–ª–∞–Ω—Å, —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω 0")
            
            # –õ–æ–≥–∏—Ä—É–µ–º –∏—Ç–æ–≥–æ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
            logger.info(f"üìä –ò–¢–û–ì–û –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏:")
            logger.info(f"   üí∞ –û–±—â–∏–π –±–∞–ª–∞–Ω—Å: ${self.balance:.2f}")
            logger.info(f"   üí∏ –î–æ—Å—Ç—É–ø–Ω–æ: ${self.available_balance:.2f}")
            logger.info(f"   üîí –í –ø–æ–∑–∏—Ü–∏—è—Ö: ${getattr(self, 'locked_balance', 0):.2f}")
            
            logger.info("üí∞ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –±–∞–ª–∞–Ω—Å–∞: {e}")
            logger.error(traceback.format_exc())
            
            # ‚úÖ –î–û–ë–ê–í–õ–ï–ù–û: –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –±–µ–∑–æ–ø–∞—Å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            if not hasattr(self, 'balance'):
                self.balance = 0.0
            if not hasattr(self, 'available_balance'):
                self.available_balance = 0.0
            
            logger.warning(f"‚ö†Ô∏è –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –±–µ–∑–æ–ø–∞—Å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: –±–∞–ª–∞–Ω—Å=${self.balance:.2f}, –¥–æ—Å—Ç—É–ø–Ω–æ=${self.available_balance:.2f}")
    
    async def _init_database(self) -> bool:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö"""
        try:
            # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò–º–ø–æ—Ä—Ç text –¥–ª—è SQLAlchemy 2.x
            from sqlalchemy import text
            
            # –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ë–î
            db = SessionLocal()
            try:
                db.execute(text("SELECT 1"))  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û!
                db.commit()
                logger.info("‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ–¥–∫–ª—é—á–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ")
                return True
            finally:
                db.close()
                
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î: {e}")
    
    # =================================================================
    # –ú–ï–¢–û–î–´ –†–ê–ë–û–¢–´ –° –¢–û–†–ì–û–í–´–ú–ò –ü–ê–†–ê–ú–ò
    # =================================================================
    
    async def _discover_all_trading_pairs(self) -> bool:
        """–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –≤—Å–µ—Ö —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä"""
        try:
            logger.info("üîç –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä...")
            
            if config.ENABLE_AUTO_PAIR_DISCOVERY and self.exchange:
                # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Ä—ã–Ω–∫–∏ —Å –±–∏—Ä–∂–∏
                markets = await self._fetch_all_markets_from_exchange()
                
                if not markets:
                    logger.warning("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ä—ã–Ω–∫–∏ —Å –±–∏—Ä–∂–∏")
                    return False
                
                # –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –∫—Ä–∏—Ç–µ—Ä–∏—è–º
                filtered_pairs = await self._filter_and_rank_pairs(markets)
                
                # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
                max_pairs = config.MAX_TRADING_PAIRS
                self.all_trading_pairs = filtered_pairs[:max_pairs]
                
                # –†–∞–∑–¥–µ–ª—è–µ–º –Ω–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
                await self._categorize_trading_pairs()
                
                logger.info(f"‚úÖ –û–±–Ω–∞—Ä—É–∂–µ–Ω–æ {len(self.all_trading_pairs)} —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä")
                logger.info(f"üìà –ê–∫—Ç–∏–≤–Ω—ã—Ö: {len(self.active_pairs)}")
                logger.info(f"üëÄ –í —Å–ø–∏—Å–∫–µ –Ω–∞–±–ª—é–¥–µ–Ω–∏—è: {len(self.watchlist_pairs)}")
                
                return True
            else:
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫
                self._load_pairs_from_config()
                return True
                
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä: {e}")
            return False
    
    async def _fetch_all_markets_from_exchange(self) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –†–ï–ê–õ–¨–ù–´–• —Ä—ã–Ω–∫–æ–≤ —Å –±–∏—Ä–∂–∏"""
        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤–∞—à —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π real_client.py
            if not hasattr(self, 'real_exchange') or not self.real_exchange:
                from ..exchange.real_client import RealExchangeClient
                self.real_exchange = RealExchangeClient()
                await self.real_exchange.connect()
            
            # –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ —Ä—ã–Ω–∫–∏
            markets = await self.real_exchange.get_all_markets()
            
            if not markets:
                logger.warning("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ä—ã–Ω–∫–∏, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–Ω—Ñ–∏–≥")
                self._load_pairs_from_config()
                return []
            
            logger.info(f"‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(markets)} –†–ï–ê–õ–¨–ù–´–• —Ä—ã–Ω–∫–æ–≤ —Å Bybit")
            return markets
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–µ–∞–ª—å–Ω—ã—Ö —Ä—ã–Ω–∫–æ–≤: {e}")
            return []
    
    async def _filter_and_rank_pairs(self, markets: List[Dict]) -> List[Dict]:
        """–§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –∏ —Ä–∞–Ω–∂–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä"""
        try:
            filtered_pairs = []
            
            for market in markets:
                # –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã
                if await self._passes_pair_filters(market):
                    # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å–∫–æ—Ä –¥–ª—è —Ä–∞–Ω–∂–∏—Ä–æ–≤–∞–Ω–∏—è
                    score = await self._calculate_pair_score(market)
                    market['trading_score'] = score
                    filtered_pairs.append(market)
            
            # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Å–∫–æ—Ä—É (–ª—É—á—à–∏–µ —Å–Ω–∞—á–∞–ª–∞)
            filtered_pairs.sort(key=lambda x: x['trading_score'], reverse=True)
            
            logger.info(f"üéØ –û—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–æ {len(filtered_pairs)} –ø–∞—Ä –∏–∑ {len(markets)}")
            return filtered_pairs
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –ø–∞—Ä: {e}")
            return []
    
    async def _passes_pair_filters(self, market: Dict) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞—Ä—ã –Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ñ–∏–ª—å—Ç—Ä–∞–º"""
        try:
            symbol = market.get('symbol', '')
            base = market.get('base', '')
            quote = market.get('quote', '')
            volume_24h = market.get('volume_24h', 0)
            price = market.get('price', 0)
            
            # –ë–∞–∑–æ–≤—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
            if not market.get('active', False):
                return False
            
            # –§–∏–ª—å—Ç—Ä –ø–æ –∫–æ—Ç–∏—Ä—É–µ–º–æ–π –≤–∞–ª—é—Ç–µ
            if quote not in config.ALLOWED_QUOTE_ASSETS:
                return False
            
            # –§–∏–ª—å—Ç—Ä –ø–æ –∏—Å–∫–ª—é—á–µ–Ω–Ω—ã–º –±–∞–∑–æ–≤—ã–º –∞–∫—Ç–∏–≤–∞–º
            if base in config.EXCLUDED_BASE_ASSETS:
                return False
            
            # –§–∏–ª—å—Ç—Ä –ø–æ –æ–±—ä–µ–º—É
            if volume_24h < config.MIN_VOLUME_24H_USD:
                return False
            
            # –§–∏–ª—å—Ç—Ä –ø–æ —Ü–µ–Ω–µ
            if price < config.MIN_PRICE_USD or price > config.MAX_PRICE_USD:
                return False
            
            # –§–∏–ª—å—Ç—Ä –ø–æ —á–µ—Ä–Ω–æ–º—É —Å–ø–∏—Å–∫—É
            if symbol in self.blacklisted_pairs:
                return False
            
            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
            change_24h = abs(market.get('change_24h', 0))
            if change_24h > 50:  # –ò—Å–∫–ª—é—á–∞–µ–º —Å–ª–∏—à–∫–æ–º –≤–æ–ª–∞—Ç–∏–ª—å–Ω—ã–µ
                return False
            
            trades_count = market.get('trades_count', 0)
            if trades_count < 100:  # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
                return False
            
            spread_percent = (market.get('ask', 0) - market.get('bid', 0)) / price * 100
            if spread_percent > 1:  # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Å–ø—Ä–µ–¥ 1%
                return False
            
            return True
            
        except Exception as e:
            logger.debug(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ñ–∏–ª—å—Ç—Ä–æ–≤ –¥–ª—è {market.get('symbol', 'unknown')}: {e}")
            return False
    
    async def _calculate_pair_score(self, market: Dict) -> float:
        """–†–∞—Å—á–µ—Ç —Å–∫–æ—Ä–∞ —Ç–æ—Ä–≥–æ–≤–æ–π –ø–∞—Ä—ã –¥–ª—è —Ä–∞–Ω–∂–∏—Ä–æ–≤–∞–Ω–∏—è"""
        try:
            score = 0.0
            
            # –°–∫–æ—Ä –ø–æ –æ–±—ä–µ–º—É (30%)
            volume_24h = market.get('volume_24h', 0)
            volume_score = min(1.0, volume_24h / 50000000)  # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∫ $50M
            score += volume_score * 0.3
            
            # –°–∫–æ—Ä –ø–æ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ —Ç–æ—Ä–≥–æ–≤ (20%)
            trades_count = market.get('trades_count', 0)
            activity_score = min(1.0, trades_count / 10000)  # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∫ 10k —Å–¥–µ–ª–æ–∫
            score += activity_score * 0.2
            
            # –°–∫–æ—Ä –ø–æ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏ (—Å–ø—Ä–µ–¥—É) (20%)
            price = market.get('price', 1)
            spread = (market.get('ask', price) - market.get('bid', price)) / price
            liquidity_score = max(0, 1 - spread * 100)  # –ß–µ–º –º–µ–Ω—å—à–µ —Å–ø—Ä–µ–¥, —Ç–µ–º –ª—É—á—à–µ
            score += liquidity_score * 0.2
            
            # –°–∫–æ—Ä –ø–æ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏ (15%)
            change_24h = abs(market.get('change_24h', 0))
            volatility_score = min(1.0, change_24h / 10)  # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∫ 10%
            score += volatility_score * 0.15
            
            # –°–∫–æ—Ä –ø–æ –ø–æ–ø—É–ª—è—Ä–Ω–æ—Å—Ç–∏ –±–∞–∑–æ–≤–æ–≥–æ –∞–∫—Ç–∏–≤–∞ (15%)
            base = market.get('base', '')
            popularity_score = self._get_asset_popularity_score(base)
            score += popularity_score * 0.15
            
            return min(1.0, score)
            
        except Exception as e:
            logger.debug(f"–û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ —Å–∫–æ—Ä–∞ –¥–ª—è {market.get('symbol', 'unknown')}: {e}")
            return 0.0
    
    def _get_asset_popularity_score(self, base_asset: str) -> float:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–∫–æ—Ä–∞ –ø–æ–ø—É–ª—è—Ä–Ω–æ—Å—Ç–∏ –∞–∫—Ç–∏–≤–∞"""
        # –ü–æ–ø—É–ª—è—Ä–Ω—ã–µ –∞–∫—Ç–∏–≤—ã –ø–æ–ª—É—á–∞—é—Ç –±–æ–ª—å—à–∏–π —Å–∫–æ—Ä
        popularity_map = {
            'BTC': 1.0, 'ETH': 0.95, 'BNB': 0.9, 'SOL': 0.85, 'ADA': 0.8,
            'XRP': 0.75, 'DOT': 0.7, 'AVAX': 0.65, 'MATIC': 0.6, 'LINK': 0.55,
            'UNI': 0.5, 'LTC': 0.45, 'BCH': 0.4, 'ATOM': 0.35, 'FIL': 0.3
        }
        return popularity_map.get(base_asset, 0.1)  # –ë–∞–∑–æ–≤—ã–π —Å–∫–æ—Ä –¥–ª—è –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã—Ö
    
    async def _categorize_trading_pairs(self):
        """–ö–∞—Ç–µ–≥–æ—Ä–∏–∑–∞—Ü–∏—è —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä"""
        try:
            # –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
            self.active_pairs.clear()
            self.watchlist_pairs.clear()
            self.trending_pairs.clear()
            self.high_volume_pairs.clear()
            
            if not self.all_trading_pairs:
                return
            
            # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Å–∫–æ—Ä—É
            sorted_pairs = sorted(self.all_trading_pairs, 
                                key=lambda x: x.get('trading_score', 0), 
                                reverse=True)
            
            # –ê–∫—Ç–∏–≤–Ω—ã–µ –ø–∞—Ä—ã (—Ç–æ–ø 30% –∏–ª–∏ –º–∞–∫—Å–∏–º—É–º –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞)
            max_active = min(config.MAX_POSITIONS, len(sorted_pairs) // 3)
            self.active_pairs = [pair['symbol'] for pair in sorted_pairs[:max_active]]
            
            # –°–ø–∏—Å–æ–∫ –Ω–∞–±–ª—é–¥–µ–Ω–∏—è (—Å–ª–µ–¥—É—é—â–∏–µ 20%)
            watchlist_count = min(50, len(sorted_pairs) // 5)
            start_idx = len(self.active_pairs)
            self.watchlist_pairs = [pair['symbol'] for pair in sorted_pairs[start_idx:start_idx + watchlist_count]]
            
            # –¢—Ä–µ–Ω–¥–æ–≤—ã–µ –ø–∞—Ä—ã (—Å –≤—ã—Å–æ–∫–∏–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ–º –∑–∞ 24—á)
            trending_pairs = [pair for pair in sorted_pairs if abs(pair.get('change_24h', 0)) > 5]
            self.trending_pairs = [pair['symbol'] for pair in trending_pairs[:20]]
            
            # –í—ã—Å–æ–∫–æ–æ–±—ä–µ–º–Ω—ã–µ –ø–∞—Ä—ã (—Ç–æ–ø –ø–æ –æ–±—ä–µ–º—É)
            volume_sorted = sorted(sorted_pairs, key=lambda x: x.get('volume_24h', 0), reverse=True)
            self.high_volume_pairs = [pair['symbol'] for pair in volume_sorted[:20]]
            
            logger.info(f"üìä –ö–∞—Ç–µ–≥–æ—Ä–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞:")
            logger.info(f"  üéØ –ê–∫—Ç–∏–≤–Ω—ã–µ: {len(self.active_pairs)}")
            logger.info(f"  üëÄ –ù–∞–±–ª—é–¥–µ–Ω–∏–µ: {len(self.watchlist_pairs)}")
            logger.info(f"  üìà –¢—Ä–µ–Ω–¥–æ–≤—ã–µ: {len(self.trending_pairs)}")
            logger.info(f"  üí∞ –í—ã—Å–æ–∫–æ–æ–±—ä–µ–º–Ω—ã–µ: {len(self.high_volume_pairs)}")
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∑–∞—Ü–∏–∏ –ø–∞—Ä: {e}")
    
    def _load_pairs_from_config(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏"""
        try:
            configured_pairs = config.get_active_trading_pairs()
            
            # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ —Ñ–æ—Ä–º–∞—Ç all_trading_pairs
            self.all_trading_pairs = [
                {
                    'symbol': symbol,
                    'base': symbol.replace('USDT', '').replace('BUSD', '').replace('USDC', ''),
                    'quote': 'USDT',
                    'trading_score': 0.5  # –°—Ä–µ–¥–Ω–∏–π —Å–∫–æ—Ä
                }
                for symbol in configured_pairs
            ]
            
            # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
            max_pairs = config.MAX_TRADING_PAIRS
            self.all_trading_pairs = self.all_trading_pairs[:max_pairs]
            self.active_pairs = [pair['symbol'] for pair in self.all_trading_pairs[:config.MAX_POSITIONS]]
            
            logger.info(f"üìä –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(self.all_trading_pairs)} –ø–∞—Ä –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏")
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø–∞—Ä –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
            # Fallback –∫ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–º—É –Ω–∞–±–æ—Ä—É
    
    # =================================================================
    # –¢–û–†–ì–û–í–´–ï –¶–ò–ö–õ–´ –ò –°–¢–†–ê–¢–ï–ì–ò–ò 
    # =================================================================
    
    async def _start_all_trading_loops(self):
        """–ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö —Ç–æ—Ä–≥–æ–≤—ã—Ö —Ü–∏–∫–ª–æ–≤"""
        try:
            logger.info("üîÑ –ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö —Ç–æ—Ä–≥–æ–≤—ã—Ö —Ü–∏–∫–ª–æ–≤...")
            
            # –û—Å–Ω–æ–≤–Ω–æ–π —Ç–æ—Ä–≥–æ–≤—ã–π —Ü–∏–∫–ª
            self.tasks['main_trading'] = asyncio.create_task(
                self._main_trading_loop(), name="main_trading"
            )
            
            # –¶–∏–∫–ª –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Ä—ã–Ω–∫–∞
            self.tasks['market_monitoring'] = asyncio.create_task(
                self._market_monitoring_loop(), name="market_monitoring"
            )
            
            # –¶–∏–∫–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä
            self.tasks['pair_discovery'] = asyncio.create_task(
                self._pair_discovery_loop(), name="pair_discovery"
            )
            
            # –¶–∏–∫–ª —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏—è–º–∏
            self.tasks['position_management'] = asyncio.create_task(
                self._position_management_loop(), name="position_management"
            )
            
            # –¶–∏–∫–ª –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Ä–∏—Å–∫–æ–≤
            self.tasks['risk_monitoring'] = asyncio.create_task(
                self._risk_monitoring_loop(), name="risk_monitoring"
            )
            
            # –¶–∏–∫–ª –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∑–¥–æ—Ä–æ–≤—å—è
            self.tasks['health_monitoring'] = asyncio.create_task(
                self._health_monitoring_loop(), name="health_monitoring"
            )
            
            # –¶–∏–∫–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
            self.tasks['performance_monitoring'] = asyncio.create_task(
                self._performance_monitoring_loop(), name="performance_monitoring"
            )
            
            # –¶–∏–∫–ª —ç–∫—Å–ø–æ—Ä—Ç–∞ –¥–∞–Ω–Ω—ã—Ö
            self.tasks['data_export'] = asyncio.create_task(
                self._data_export_loop(), name="data_export"
            )
            
            # –¶–∏–∫–ª—ã –º–∞—à–∏–Ω–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è (–µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ)
            if config.ENABLE_MACHINE_LEARNING:
                self.tasks['ml_training'] = asyncio.create_task(
                    self._ml_training_loop(), name="ml_training"
                )
                self.tasks['ml_prediction'] = asyncio.create_task(
                    self._ml_prediction_loop(), name="ml_prediction"
                )
            
            # –¶–∏–∫–ª—ã –∞–Ω–∞–ª–∏–∑–∞ –Ω–æ–≤–æ—Å—Ç–µ–π (–µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ)
            if config.ENABLE_NEWS_ANALYSIS:
                self.tasks['news_collection'] = asyncio.create_task(
                    self._news_collection_loop(), name="news_collection"
                )
                self.tasks['sentiment_analysis'] = asyncio.create_task(
                    self._sentiment_analysis_loop(), name="sentiment_analysis"
                )
            
            # –¶–∏–∫–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–±—ã—Ç–∏–π
            self.tasks['event_processing'] = asyncio.create_task(
                self._event_processing_loop(), name="event_processing"
            )
            
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∑–¥–æ—Ä–æ–≤—å–µ –∑–∞–¥–∞—á
            for task_name in self.tasks:
                self.task_health[task_name] = 'starting'
            
            logger.info(f"‚úÖ –ó–∞–ø—É—â–µ–Ω–æ {len(self.tasks)} —Ç–æ—Ä–≥–æ–≤—ã—Ö —Ü–∏–∫–ª–æ–≤")
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ —Ç–æ—Ä–≥–æ–≤—ã—Ö —Ü–∏–∫–ª–æ–≤: {e}")
            raise
    
    async def _main_trading_loop(self):
        """–ì–ª–∞–≤–Ω—ã–π —Ç–æ—Ä–≥–æ–≤—ã–π —Ü–∏–∫–ª - –° –ö–û–ù–¢–†–û–õ–ï–ú RATE LIMITS"""
        logger.info("üöÄ –ó–∞–ø—É—Å–∫ –≥–ª–∞–≤–Ω–æ–≥–æ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ —Ü–∏–∫–ª–∞...")
        
        cycle_count = 0
        last_request_times = defaultdict(lambda: 0)  # –î–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –∑–∞–ø—Ä–æ—Å–æ–≤
        
        while self.is_running and self.status == BotStatus.RUNNING:
            try:
                cycle_count += 1
                cycle_start = time.time()
                
                logger.info(f"üîÑ –¶–∏–∫–ª #{cycle_count} - –∞–Ω–∞–ª–∏–∑ {len(self.active_pairs)} –ø–∞—Ä")
                
                # === –ö–û–ù–¢–†–û–õ–¨ RATE LIMITS ===
                # Bybit limits: 120 requests per minute –¥–ª—è spot
                max_requests_per_minute = 100  # –û—Å—Ç–∞–≤–ª—è–µ–º –∑–∞–ø–∞—Å
                min_request_interval = 60.0 / max_requests_per_minute  # ~0.6 —Å–µ–∫—É–Ω–¥—ã –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
                
                # 1. –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏—è–º–∏ (—Å –∑–∞–¥–µ—Ä–∂–∫–æ–π –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏)
                await self._manage_all_positions()
                await asyncio.sleep(min_request_interval)
                
                # 2. –û–±–Ω–æ–≤–ª—è–µ–º —Ä—ã–Ω–æ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å –∫–æ–Ω—Ç—Ä–æ–ª–µ–º —á–∞—Å—Ç–æ—Ç—ã
                for i, symbol in enumerate(self.active_pairs):
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è —Å–∏–º–≤–æ–ª–∞
                    last_time = last_request_times[symbol]
                    current_time = time.time()
                    
                    if current_time - last_time < min_request_interval:
                        await asyncio.sleep(min_request_interval - (current_time - last_time))
                    
                    # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ
                    await self._update_market_data_for_symbol(symbol)
                    last_request_times[symbol] = time.time()
                    
                    # –ü–∞—É–∑–∞ –º–µ–∂–¥—É —Å–∏–º–≤–æ–ª–∞–º–∏
                    if i < len(self.active_pairs) - 1:
                        await asyncio.sleep(min_request_interval)
                
                # 3. –ò—â–µ–º —Ç–æ—Ä–≥–æ–≤—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏
                opportunities = await self._find_all_trading_opportunities()
                
                # 4. –ò—Å–ø–æ–ª–Ω—è–µ–º –ª—É—á—à–∏–µ —Å–¥–µ–ª–∫–∏
                trades_executed = 0
                if opportunities:
                    trades_executed = await self._execute_best_trades(opportunities)
                
                # 5. –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
                cycle_duration = time.time() - cycle_start
                logger.info(f"‚è±Ô∏è –¶–∏–∫–ª #{cycle_count} –∑–∞–≤–µ—Ä—à–µ–Ω –∑–∞ {cycle_duration:.2f}—Å, —Å–¥–µ–ª–æ–∫: {trades_executed}")
                
                # 6. –ê–¥–∞–ø—Ç–∏–≤–Ω–∞—è –ø–∞—É–∑–∞
                # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª –µ—Å–ª–∏ –Ω–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π
                if len(opportunities) == 0:
                    analysis_interval = min(getattr(config, 'ANALYSIS_INTERVAL_SECONDS', 60) * 1.5, 180)
                else:
                    analysis_interval = getattr(config, 'ANALYSIS_INTERVAL_SECONDS', 60)
                
                wait_time = max(analysis_interval - cycle_duration, 10)  # –ú–∏–Ω–∏–º—É–º 10 —Å–µ–∫—É–Ω–¥
                logger.debug(f"‚è∞ –û–∂–∏–¥–∞–Ω–∏–µ {wait_time:.1f}—Å –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ —Ü–∏–∫–ª–∞...")
                await asyncio.sleep(wait_time)
                
            except asyncio.CancelledError:
                logger.info("üõë –ì–ª–∞–≤–Ω—ã–π —Ç–æ—Ä–≥–æ–≤—ã–π —Ü–∏–∫–ª –æ—Ç–º–µ–Ω–µ–Ω")
                break
                
            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ —Ç–æ—Ä–≥–æ–≤–æ–º —Ü–∏–∫–ª–µ: {e}")
                logger.error(traceback.format_exc())
                # –ü—Ä–∏ –æ—à–∏–±–∫–µ –∂–¥–µ–º –±–æ–ª—å—à–µ –≤—Ä–µ–º–µ–Ω–∏
                await asyncio.sleep(60)
        
        logger.info("‚úÖ –ì–ª–∞–≤–Ω—ã–π —Ç–æ—Ä–≥–æ–≤—ã–π —Ü–∏–∫–ª –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
        
    async def _update_market_data_for_symbol(self, symbol: str):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–¥–Ω–æ–≥–æ —Å–∏–º–≤–æ–ª–∞ —Å –∫–æ–Ω—Ç—Ä–æ–ª–µ–º –æ—à–∏–±–æ–∫"""
        try:
            if hasattr(self, 'data_collector') and self.data_collector:
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º data_collector
                market_data = await self.data_collector.collect_market_data(symbol)
                return market_data
            else:
                # Fallback –Ω–∞ –ø—Ä—è–º–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ
                if hasattr(self.exchange_client, 'fetch_ohlcv'):
                    candles = await self.exchange_client.fetch_ohlcv(symbol, '5m', limit=50)
                    if candles and len(candles) > 0:
                        if symbol not in self.candle_cache:
                            self.candle_cache[symbol] = deque(maxlen=100)
                        
                        for candle in candles[-10:]:
                            candle_data = {
                                'timestamp': candle[0],
                                'open': float(candle[1]),
                                'high': float(candle[2]),
                                'low': float(candle[3]),
                                'close': float(candle[4]),
                                'volume': float(candle[5])
                            }
                            self.candle_cache[symbol].append(candle_data)
                        
                        return True
            
            return False
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {symbol}: {e}")
            return False
        
    async def _execute_best_trades(self, opportunities: list) -> int:
        """–ò—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –ª—É—á—à–∏—Ö —Ç–æ—Ä–≥–æ–≤—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π —Å –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ú –≤—ã–∑–æ–≤–æ–º calculate_position_size"""
        try:
            trades_executed = 0
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏
            if not opportunities:
                logger.debug("üìä –ù–µ—Ç —Ç–æ—Ä–≥–æ–≤—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π –¥–ª—è –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è")
                return 0
            
            # –§–∏–ª—å—Ç—Ä—É–µ–º –∏ —Ä–∞–Ω–∂–∏—Ä—É–µ–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏
            logger.info(f"üìä –ù–∞–π–¥–µ–Ω–æ —Ç–æ—Ä–≥–æ–≤—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π: {len(opportunities)}")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç—ã
            max_trades = min(
                getattr(config, 'MAX_DAILY_TRADES', 50) - getattr(self, 'trades_today', 0),
                getattr(config, 'MAX_POSITIONS', 15) - len(getattr(self, 'positions', {})),
                3  # –ú–∞–∫—Å–∏–º—É–º 3 —Å–¥–µ–ª–∫–∏ –∑–∞ —Ü–∏–∫–ª
            )
            
            if max_trades <= 0:
                logger.warning("‚ö†Ô∏è –î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç —Å–¥–µ–ª–æ–∫ –∏–ª–∏ –ø–æ–∑–∏—Ü–∏–π")
                return 0
            
            # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏
            sorted_opportunities = sorted(
                opportunities,
                key=lambda x: x.get('confidence', 0),
                reverse=True
            )
            
            # –ò—Å–ø–æ–ª–Ω—è–µ–º –ª—É—á—à–∏–µ —Å–¥–µ–ª–∫–∏
            for opportunity in sorted_opportunities[:max_trades]:
                symbol = opportunity['symbol']
                signal = opportunity['signal']
                confidence = opportunity.get('confidence', 0.6)
                price = opportunity['price']
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å
                min_confidence = getattr(config, 'MIN_CONFIDENCE', 0.6)
                if confidence < min_confidence:
                    logger.debug(f"‚è≠Ô∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º {symbol}: –Ω–∏–∑–∫–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å {confidence:.2f} < {min_confidence}")
                    continue
                
                # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –º–µ—Ç–æ–¥ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–º
                if hasattr(self._calculate_position_size, '__call__'):
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –º–µ—Ç–æ–¥ –∫–æ—Ä—É—Ç–∏–Ω–æ–π
                    import inspect
                    if inspect.iscoroutinefunction(self._calculate_position_size):
                        position_size = await self._calculate_position_size(symbol, price)
                    else:
                        # –ú–µ—Ç–æ–¥ —Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π - –≤—ã–∑—ã–≤–∞–µ–º –±–µ–∑ await
                        position_size = self._calculate_position_size(symbol, price)
                else:
                    # –ï—Å–ª–∏ –º–µ—Ç–æ–¥–∞ –Ω–µ—Ç, –∏—Å–ø–æ–ª—å–∑—É–µ–º –±–∞–∑–æ–≤—ã–π —Ä–∞—Å—á–µ—Ç
                    logger.warning("‚ö†Ô∏è –ú–µ—Ç–æ–¥ _calculate_position_size –Ω–µ –Ω–∞–π–¥–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –±–∞–∑–æ–≤—ã–π —Ä–∞—Å—á–µ—Ç")
                    # –ë–∞–∑–æ–≤—ã–π —Ä–∞—Å—á–µ—Ç —Ä–∞–∑–º–µ—Ä–∞ –ø–æ–∑–∏—Ü–∏–∏
                    balance = getattr(self, 'available_balance', 10000)
                    risk_amount = balance * (getattr(config, 'RISK_PER_TRADE_PERCENT', 1.5) / 100)
                    position_size = risk_amount / price
                    
                if position_size <= 0:
                    logger.warning(f"‚ö†Ô∏è –ù—É–ª–µ–≤–æ–π —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è {symbol}")
                    continue
                
                # –û–∫—Ä—É–≥–ª—è–µ–º —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ –¥–æ —Ä–∞–∑—É–º–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
                # –î–ª—è Bybit –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –æ–±—ã—á–Ω–æ 0.001
                min_size = 0.001
                if position_size < min_size:
                    logger.warning(f"‚ö†Ô∏è –†–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ {position_size} –º–µ–Ω—å—à–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ {min_size}")
                    position_size = min_size
                
                # –û–∫—Ä—É–≥–ª—è–µ–º –¥–æ 3 –∑–Ω–∞–∫–æ–≤ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π
                position_size = round(position_size, 3)
                
                # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Å–¥–µ–ª–∫–∏
                trade_data = {
                    'confidence': confidence,
                    'stop_loss': opportunity.get('stop_loss'),
                    'take_profit': opportunity.get('take_profit'),
                    'strategy': opportunity.get('strategy', 'unknown'),
                    'indicators': opportunity.get('indicators', {}),
                    'market_conditions': opportunity.get('market_conditions', {}),
                    'risk_reward_ratio': opportunity.get('risk_reward_ratio')
                }
                
                # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º risk/reward –µ—Å–ª–∏ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω
                if not trade_data.get('risk_reward_ratio') and trade_data.get('stop_loss') and trade_data.get('take_profit'):
                    if signal.upper() == 'BUY':
                        risk = price - trade_data['stop_loss']
                        reward = trade_data['take_profit'] - price
                    else:  # SELL
                        risk = trade_data['stop_loss'] - price
                        reward = price - trade_data['take_profit']
                    
                    if risk > 0:
                        trade_data['risk_reward_ratio'] = reward / risk
                
                # –õ–æ–≥–∏—Ä—É–µ–º –ø–æ–¥–≥–æ—Ç–æ–≤–∫—É —Å–¥–µ–ª–∫–∏
                logger.info("üéØ –ü–û–î–ì–û–¢–û–í–ö–ê –°–î–ï–õ–ö–ò:")
                logger.info(f"üìä –°–∏–º–≤–æ–ª: {symbol}")
                logger.info(f"üìà –°–∏–≥–Ω–∞–ª: {signal}")
                logger.info(f"üíµ –¶–µ–Ω–∞: ${price:.4f}")
                logger.info(f"üìè –†–∞–∑–º–µ—Ä: {position_size}")
                if trade_data.get('stop_loss'):
                    logger.info(f"üõë –°—Ç–æ–ø-–ª–æ—Å—Å: ${trade_data['stop_loss']:.4f}")
                if trade_data.get('take_profit'):
                    logger.info(f"üéØ –¢–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç: ${trade_data['take_profit']:.4f}")
                if trade_data.get('risk_reward_ratio'):
                    logger.info(f"‚öñÔ∏è Risk/Reward: 1:{trade_data['risk_reward_ratio']:.2f}")
                logger.info(f"üìä –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {confidence:.2f}")
                logger.info(f"üîß –°—Ç—Ä–∞—Ç–µ–≥–∏—è: {trade_data.get('strategy')}")
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∂–∏–º —Ç–æ—Ä–≥–æ–≤–ª–∏
                paper_trading = config.PAPER_TRADING
                testnet = config.TESTNET
                live_trading = config.LIVE_TRADING
                
                # –õ–æ–≥–∏—Ä—É–µ–º —Ä–µ–∂–∏–º
                logger.debug(f"üîç –†–µ–∂–∏–º—ã: PAPER_TRADING={paper_trading}, TESTNET={testnet}, LIVE_TRADING={live_trading}")
                
                 # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–µ–∂–∏–º –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç ‚Äî paper ‚Üí live ‚Üí testnet ‚Üí fallback)
                if paper_trading:
                    logger.info("üìù –†–ï–ñ–ò–ú PAPER TRADING - —Å–∏–º—É–ª—è—Ü–∏—è —Å–¥–µ–ª–∫–∏")
                    success = await self._simulate_trade(symbol, signal, position_size, price, trade_data)
                elif live_trading:
                    if testnet:
                        logger.info("üß™ –†–ï–ñ–ò–ú TESTNET - —Ä–µ–∞–ª—å–Ω–∞—è —Å–¥–µ–ª–∫–∞ –Ω–∞ —Ç–µ—Å—Ç–æ–≤–æ–π –±–∏—Ä–∂–µ")
                    else:
                        logger.info("üí∏ –†–ï–ñ–ò–ú LIVE TRADING - —Ä–µ–∞–ª—å–Ω–∞—è —Å–¥–µ–ª–∫–∞ –Ω–∞ –æ—Å–Ω–æ–≤–Ω–æ–π –±–∏—Ä–∂–µ")
                    success = await self._execute_real_order(symbol, signal, position_size, price, trade_data)
                else:
                    logger.warning("‚ö†Ô∏è –ù–µ —É–∫–∞–∑–∞–Ω—ã LIVE_TRADING –∏–ª–∏ PAPER_TRADING ‚Äî –ø–µ—Ä–µ—Ö–æ–¥–∏–º –≤ —Å–∏–º—É–ª—è—Ü–∏—é")
                    success = await self._simulate_trade(symbol, signal, position_size, price, trade_data)
                    
                if success:
                    trades_executed += 1
                    self.trades_today = getattr(self, 'trades_today', 0) + 1
                    logger.info(f"‚úÖ –°–¥–µ–ª–∫–∞ #{trades_executed} –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ")
                    
                    # –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏–∏
                    if not hasattr(self, 'positions'):
                        self.positions = {}
                        
                    self.positions[symbol] = {
                        'side': signal,
                        'size': position_size,
                        'entry_price': price,
                        'stop_loss': trade_data.get('stop_loss'),
                        'take_profit': trade_data.get('take_profit'),
                        'strategy': trade_data.get('strategy'),
                        'confidence': confidence,
                        'timestamp': datetime.utcnow()
                    }
                    
                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
                    if hasattr(self, 'notifier') and self.notifier:
                        try:
                            await self.notifier.send_trade_notification(
                                symbol=symbol,
                                side=signal,
                                price=price,
                                amount=position_size,
                                strategy=trade_data.get('strategy'),
                                confidence=confidence
                            )
                        except Exception as e:
                            logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
                else:
                    logger.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å —Å–¥–µ–ª–∫—É –¥–ª—è {symbol}")
                    
                    # –î–æ–±–∞–≤–ª—è–µ–º —Å–∏–º–≤–æ–ª –≤ —á–µ—Ä–Ω—ã–π —Å–ø–∏—Å–æ–∫ –Ω–∞ –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è
                    if hasattr(self, 'trade_cooldown'):
                        self.trade_cooldown[symbol] = datetime.utcnow() + timedelta(minutes=30)
                        logger.info(f"‚è∞ {symbol} –¥–æ–±–∞–≤–ª–µ–Ω –≤ cooldown –Ω–∞ 30 –º–∏–Ω—É—Ç")
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            if trades_executed > 0:
                logger.info(f"üìä –ò—Ç–æ–≥–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ —Å–¥–µ–ª–æ–∫ –≤ —ç—Ç–æ–º —Ü–∏–∫–ª–µ: {trades_executed}")
                logger.info(f"üìä –í—Å–µ–≥–æ —Å–¥–µ–ª–æ–∫ –∑–∞ —Å–µ–≥–æ–¥–Ω—è: {self.trades_today}")
                logger.info(f"üìä –û—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏–π: {len(self.positions)}")
            
            return trades_executed
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è —Å–¥–µ–ª–æ–∫: {e}")
            import traceback
            traceback.print_exc()
            return 0
            
    async def _simulate_trade(self, symbol: str, signal: str, position_size: float,
                             price: float, trade_data: Dict[str, Any]) -> bool:
        """
        –°–∏–º—É–ª—è—Ü–∏—è —Ç–æ—Ä–≥–æ–≤–æ–π –æ–ø–µ—Ä–∞—Ü–∏–∏ –¥–ª—è —Ä–µ–∂–∏–º–∞ Paper Trading
        
        Args:
            symbol: –¢–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞
            signal: –¢–∏–ø —Å–∏–≥–Ω–∞–ª–∞ (BUY/SELL)
            position_size: –†–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏
            price: –¶–µ–Ω–∞ –≤—Ö–æ–¥–∞
            trade_data: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å–¥–µ–ª–∫–∏
            
        Returns:
            bool: True –µ—Å–ª–∏ —Å–∏–º—É–ª—è—Ü–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ
        """
        try:
            logger.info("üìù –°–ò–ú–£–õ–Ø–¶–ò–Ø –°–î–ï–õ–ö–ò (Paper Trading)")
            logger.info(f"üìä –°–∏–º–≤–æ–ª: {symbol}")
            logger.info(f"üìà –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: {signal}")
            logger.info(f"üíµ –¶–µ–Ω–∞ –≤—Ö–æ–¥–∞: ${price:.4f}")
            logger.info(f"üìè –†–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏: {position_size}")
            
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID –¥–ª—è —Å–∏–º—É–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –æ—Ä–¥–µ—Ä–∞
            import uuid
            order_id = f"PAPER_{uuid.uuid4().hex[:8]}"
            
            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—Ç–æ–∏–º–æ—Å—Ç—å –ø–æ–∑–∏—Ü–∏–∏
            position_value = position_size * price
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ—Å—Ç—å –±–∞–ª–∞–Ω—Å–∞
            available_balance = getattr(self, 'paper_balance', 10000)
            if position_value > available_balance:
                logger.error(f"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤: –Ω—É–∂–Ω–æ ${position_value:.2f}, –¥–æ—Å—Ç—É–ø–Ω–æ ${available_balance:.2f}")
                return False
            
            # –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –æ —Å–∏–º—É–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ–π —Å–¥–µ–ª–∫–µ
            simulated_trade = {
                'order_id': order_id,
                'symbol': symbol,
                'side': signal,
                'size': position_size,
                'entry_price': price,
                'position_value': position_value,
                'stop_loss': trade_data.get('stop_loss'),
                'take_profit': trade_data.get('take_profit'),
                'strategy': trade_data.get('strategy', 'unknown'),
                'confidence': trade_data.get('confidence', 0.6),
                'timestamp': datetime.utcnow(),
                'status': 'FILLED',
                'pnl': 0.0,
                'pnl_percent': 0.0,
                'commission': position_value * 0.001  # 0.1% –∫–æ–º–∏—Å—Å–∏—è
            }
            
            # –û–±–Ω–æ–≤–ª—è–µ–º paper –±–∞–ª–∞–Ω—Å
            self.paper_balance = available_balance - position_value - simulated_trade['commission']
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ paper –ø–æ–∑–∏—Ü–∏–∏
            if not hasattr(self, 'paper_positions'):
                self.paper_positions = {}
            
            self.paper_positions[symbol] = simulated_trade
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é paper —Å–¥–µ–ª–æ–∫
            if not hasattr(self, 'paper_trades_history'):
                self.paper_trades_history = []
            
            self.paper_trades_history.append(simulated_trade.copy())
            
            # –õ–æ–≥–∏—Ä—É–µ–º –¥–µ—Ç–∞–ª–∏ —Å–¥–µ–ª–∫–∏
            logger.info(f"‚úÖ –°–∏–º—É–ª–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å–¥–µ–ª–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞!")
            logger.info(f"üîñ Order ID: {order_id}")
            logger.info(f"üí∞ –°—Ç–æ–∏–º–æ—Å—Ç—å –ø–æ–∑–∏—Ü–∏–∏: ${position_value:.2f}")
            logger.info(f"üí∏ –ö–æ–º–∏—Å—Å–∏—è: ${simulated_trade['commission']:.2f}")
            logger.info(f"üíµ –û—Å—Ç–∞—Ç–æ–∫ –±–∞–ª–∞–Ω—Å–∞: ${self.paper_balance:.2f}")
            
            if trade_data.get('stop_loss'):
                potential_loss = abs(price - trade_data['stop_loss']) * position_size
                logger.info(f"üõë Stop Loss: ${trade_data['stop_loss']:.4f} (—Ä–∏—Å–∫: ${potential_loss:.2f})")
                
            if trade_data.get('take_profit'):
                potential_profit = abs(trade_data['take_profit'] - price) * position_size
                logger.info(f"üéØ Take Profit: ${trade_data['take_profit']:.4f} (–ø–æ—Ç–µ–Ω—Ü–∏–∞–ª: ${potential_profit:.2f})")
            
            if trade_data.get('risk_reward_ratio'):
                logger.info(f"‚öñÔ∏è Risk/Reward: 1:{trade_data['risk_reward_ratio']:.2f}")
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Å–∏–º—É–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏
            if hasattr(self, '_monitor_paper_position'):
                asyncio.create_task(self._monitor_paper_position(symbol, simulated_trade))
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            if not hasattr(self, 'paper_stats'):
                self.paper_stats = {
                    'total_trades': 0,
                    'winning_trades': 0,
                    'losing_trades': 0,
                    'total_pnl': 0.0,
                    'total_commission': 0.0,
                    'max_drawdown': 0.0,
                    'best_trade': 0.0,
                    'worst_trade': 0.0,
                    'average_win': 0.0,
                    'average_loss': 0.0,
                    'win_rate': 0.0,
                    'profit_factor': 0.0
                }
            
            self.paper_stats['total_trades'] += 1
            self.paper_stats['total_commission'] += simulated_trade['commission']
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Å–∏–º—É–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ–π —Å–¥–µ–ª–∫–µ
            if hasattr(self, 'notifier') and self.notifier:
                try:
                    message = f"üìù PAPER TRADE EXECUTED\n"
                    message += f"Symbol: {symbol}\n"
                    message += f"Side: {signal}\n"
                    message += f"Price: ${price:.4f}\n"
                    message += f"Size: {position_size}\n"
                    message += f"Value: ${position_value:.2f}\n"
                    message += f"Strategy: {trade_data.get('strategy', 'unknown')}\n"
                    message += f"Balance: ${self.paper_balance:.2f}"
                    
                    await self.notifier.send_message(message)
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–∏–º—É–ª—è—Ü–∏–∏ —Å–¥–µ–ª–∫–∏: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    async def _monitor_paper_position(self, symbol: str, position: Dict[str, Any]):
        """
        –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Å–∏–º—É–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è P&L
        
        Args:
            symbol: –¢–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞
            position: –î–∞–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
        """
        try:
            while symbol in self.paper_positions:
                await asyncio.sleep(10)  # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫—É–Ω–¥
                
                # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É
                current_price = await self._get_current_price(symbol)
                if not current_price:
                    continue
                
                # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º P&L
                entry_price = position['entry_price']
                size = position['size']
                side = position['side']
                
                if side.upper() == 'BUY':
                    pnl = (current_price - entry_price) * size
                    pnl_percent = ((current_price - entry_price) / entry_price) * 100
                else:  # SELL
                    pnl = (entry_price - current_price) * size
                    pnl_percent = ((entry_price - current_price) / entry_price) * 100
                
                # –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é
                self.paper_positions[symbol]['current_price'] = current_price
                self.paper_positions[symbol]['pnl'] = pnl
                self.paper_positions[symbol]['pnl_percent'] = pnl_percent
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–æ–ø-–ª–æ—Å—Å
                if position.get('stop_loss'):
                    if (side.upper() == 'BUY' and current_price <= position['stop_loss']) or \
                       (side.upper() == 'SELL' and current_price >= position['stop_loss']):
                        logger.warning(f"üõë STOP LOSS —Å—Ä–∞–±–æ—Ç–∞–ª –¥–ª—è {symbol} @ ${current_price:.4f}")
                        await self._close_paper_position(symbol, current_price, 'STOP_LOSS')
                        break
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç
                if position.get('take_profit'):
                    if (side.upper() == 'BUY' and current_price >= position['take_profit']) or \
                       (side.upper() == 'SELL' and current_price <= position['take_profit']):
                        logger.info(f"üéØ TAKE PROFIT —Å—Ä–∞–±–æ—Ç–∞–ª –¥–ª—è {symbol} @ ${current_price:.4f}")
                        await self._close_paper_position(symbol, current_price, 'TAKE_PROFIT')
                        break
                
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ paper –ø–æ–∑–∏—Ü–∏–∏: {e}")
    
    async def _close_paper_position(self, symbol: str, exit_price: float, reason: str):
        """
        –ó–∞–∫—Ä—ã—Ç–∏–µ —Å–∏–º—É–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏
        
        Args:
            symbol: –¢–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞
            exit_price: –¶–µ–Ω–∞ –≤—ã—Ö–æ–¥–∞
            reason: –ü—Ä–∏—á–∏–Ω–∞ –∑–∞–∫—Ä—ã—Ç–∏—è
        """
        try:
            if symbol not in self.paper_positions:
                return
            
            position = self.paper_positions[symbol]
            
            # –§–∏–Ω–∞–ª—å–Ω—ã–π —Ä–∞—Å—á–µ—Ç P&L
            entry_price = position['entry_price']
            size = position['size']
            side = position['side']
            
            if side.upper() == 'BUY':
                pnl = (exit_price - entry_price) * size
            else:  # SELL
                pnl = (entry_price - exit_price) * size
            
            # –ö–æ–º–∏—Å—Å–∏—è –∑–∞ –∑–∞–∫—Ä—ã—Ç–∏–µ
            exit_commission = size * exit_price * 0.001
            total_commission = position['commission'] + exit_commission
            net_pnl = pnl - exit_commission
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –±–∞–ª–∞–Ω—Å
            self.paper_balance += position['position_value'] + net_pnl
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            self.paper_stats['total_pnl'] += net_pnl
            
            if net_pnl > 0:
                self.paper_stats['winning_trades'] += 1
                self.paper_stats['best_trade'] = max(self.paper_stats['best_trade'], net_pnl)
            else:
                self.paper_stats['losing_trades'] += 1
                self.paper_stats['worst_trade'] = min(self.paper_stats['worst_trade'], net_pnl)
            
            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º win rate
            total = self.paper_stats['winning_trades'] + self.paper_stats['losing_trades']
            if total > 0:
                self.paper_stats['win_rate'] = (self.paper_stats['winning_trades'] / total) * 100
            
            # –õ–æ–≥–∏—Ä—É–µ–º –∑–∞–∫—Ä—ã—Ç–∏–µ
            logger.info(f"üìù PAPER POSITION CLOSED: {symbol}")
            logger.info(f"üì§ –ü—Ä–∏—á–∏–Ω–∞: {reason}")
            logger.info(f"üíµ –¶–µ–Ω–∞ –≤—ã—Ö–æ–¥–∞: ${exit_price:.4f}")
            logger.info(f"üí∞ P&L: ${net_pnl:.2f} ({(net_pnl/position['position_value'])*100:.2f}%)")
            logger.info(f"üíµ –ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å: ${self.paper_balance:.2f}")
            logger.info(f"üìä Win Rate: {self.paper_stats['win_rate']:.1f}%")
            
            # –£–¥–∞–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é
            del self.paper_positions[symbol]
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è paper –ø–æ–∑–∏—Ü–∏–∏: {e}")
            
    async def _get_current_price(self, symbol: str) -> Optional[float]:
        """
        –ü–æ–ª—É—á–∞–µ—Ç —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É –¥–ª—è —Å–∏–º–≤–æ–ª–∞
        
        Args:
            symbol: –¢–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞
            
        Returns:
            Optional[float]: –¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞ –∏–ª–∏ None
        """
        try:
            # –°–ø–æ—Å–æ–± 1: –ß–µ—Ä–µ–∑ enhanced exchange client —Å –∫–µ—à–µ–º
            if hasattr(self, 'enhanced_exchange_client') and self.enhanced_exchange_client:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–µ—à —Ü–µ–Ω –µ—Å–ª–∏ –µ—Å—Ç—å
                if hasattr(self.enhanced_exchange_client, 'price_cache'):
                    cached_price = self.enhanced_exchange_client.price_cache.get(symbol)
                    if cached_price and cached_price.get('timestamp'):
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–∫—Ç—É–∞–ª—å–Ω–æ—Å—Ç—å (–Ω–µ —Å—Ç–∞—Ä—à–µ 5 —Å–µ–∫—É–Ω–¥)
                        age = (datetime.utcnow() - cached_price['timestamp']).total_seconds()
                        if age < 5:
                            return cached_price['price']
                
                # –ü—Ä–æ–±—É–µ–º —á–µ—Ä–µ–∑ V5 API
                if hasattr(self.enhanced_exchange_client, 'v5_client'):
                    try:
                        ticker = await self.enhanced_exchange_client.v5_client.get_ticker(
                            category='linear',
                            symbol=symbol
                        )
                        if ticker and ticker.get('retCode') == 0:
                            result = ticker.get('result', {})
                            if result.get('list'):
                                return float(result['list'][0].get('lastPrice', 0))
                    except Exception as e:
                        logger.debug(f"V5 ticker error: {e}")
            
            # –°–ø–æ—Å–æ–± 2: –ß–µ—Ä–µ–∑ –±–∞–∑–æ–≤—ã–π exchange client
            if hasattr(self, 'exchange_client') and self.exchange_client:
                try:
                    # –ú–µ—Ç–æ–¥ fetch_ticker –¥–ª—è CCXT
                    if hasattr(self.exchange_client, 'fetch_ticker'):
                        ticker = await self.exchange_client.fetch_ticker(symbol)
                        if ticker and 'last' in ticker:
                            return float(ticker['last'])
                    # –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –º–µ—Ç–æ–¥ get_ticker
                    elif hasattr(self.exchange_client, 'get_ticker'):
                        ticker = await self.exchange_client.get_ticker(symbol)
                        if ticker:
                            return float(ticker.get('last', 0))
                except Exception as e:
                    logger.debug(f"Exchange client ticker error: {e}")
            
            # –°–ø–æ—Å–æ–± 3: –ß–µ—Ä–µ–∑ WebSocket –¥–∞–Ω–Ω—ã–µ –µ—Å–ª–∏ –µ—Å—Ç—å
            if hasattr(self, 'websocket_manager') and self.websocket_manager:
                ws_data = getattr(self.websocket_manager, 'market_data', {})
                if symbol in ws_data and 'price' in ws_data[symbol]:
                    return float(ws_data[symbol]['price'])
            
            # –°–ø–æ—Å–æ–± 4: –ò–∑ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Å–≤–µ—á–µ–π
            if hasattr(self, 'data_collector') and self.data_collector:
                try:
                    # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é —Å–≤–µ—á—É
                    candles = await self.data_collector.get_latest_candles(symbol, limit=1)
                    if candles and len(candles) > 0:
                        return float(candles[-1]['close'])
                except Exception as e:
                    logger.debug(f"Data collector error: {e}")
            
            # –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–æ, –ø—Ä–æ–±—É–µ–º –ø—Ä–æ—Å—Ç–æ–π API –∑–∞–ø—Ä–æ—Å
            logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ü–µ–Ω—É –¥–ª—è {symbol} —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–º–∏ –º–µ—Ç–æ–¥–∞–º–∏")
            
            # Fallback: –ø—Ä—è–º–æ–π –∑–∞–ø—Ä–æ—Å –∫ Bybit API
            try:
                import aiohttp
                async with aiohttp.ClientSession() as session:
                    url = f"https://api-testnet.bybit.com/v5/market/tickers?category=linear&symbol={symbol}"
                    if not getattr(config, 'TESTNET', True):
                        url = f"https://api.bybit.com/v5/market/tickers?category=linear&symbol={symbol}"
                    
                    async with session.get(url) as response:
                        if response.status == 200:
                            data = await response.json()
                            if data.get('retCode') == 0:
                                result = data.get('result', {})
                                if result.get('list'):
                                    return float(result['list'][0].get('lastPrice', 0))
            except Exception as e:
                logger.error(f"‚ùå Fallback API error: {e}")
            
            return None
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–π —Ü–µ–Ω—ã –¥–ª—è {symbol}: {e}")
            return None
    
    async def _set_position_sl_tp(self, symbol: str, stop_loss: Optional[float], 
                                 take_profit: Optional[float]) -> bool:
        """
        –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Å—Ç–æ–ø-–ª–æ—Å—Å –∏ —Ç–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç –¥–ª—è –ø–æ–∑–∏—Ü–∏–∏
        
        Args:
            symbol: –¢–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞
            stop_loss: –¶–µ–Ω–∞ —Å—Ç–æ–ø-–ª–æ—Å—Å–∞
            take_profit: –¶–µ–Ω–∞ —Ç–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç–∞
            
        Returns:
            bool: True –µ—Å–ª–∏ —É—Å–ø–µ—à–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ
        """
        try:
            if not stop_loss and not take_profit:
                return True
            
            logger.info(f"üéØ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ SL/TP –¥–ª—è {symbol}")
            
            # –ß–µ—Ä–µ–∑ V5 API
            if hasattr(self, 'enhanced_exchange_client') and self.enhanced_exchange_client:
                if hasattr(self.enhanced_exchange_client, 'v5_client'):
                    try:
                        params = {
                            'category': 'linear',
                            'symbol': symbol,
                            'positionIdx': 0  # One-way mode
                        }
                        
                        if stop_loss:
                            params['stopLoss'] = str(stop_loss)
                            params['slTriggerBy'] = 'LastPrice'
                            logger.info(f"üõë Stop Loss: ${stop_loss:.4f}")
                        
                        if take_profit:
                            params['takeProfit'] = str(take_profit)
                            params['tpTriggerBy'] = 'LastPrice'
                            logger.info(f"üéØ Take Profit: ${take_profit:.4f}")
                        
                        result = await self.enhanced_exchange_client.v5_client.set_trading_stop(**params)
                        
                        if result and result.get('retCode') == 0:
                            logger.info(f"‚úÖ SL/TP —É—Å–ø–µ—à–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –¥–ª—è {symbol}")
                            return True
                        else:
                            error = result.get('retMsg', 'Unknown error') if result else 'No response'
                            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ SL/TP: {error}")
                            
                    except Exception as e:
                        logger.error(f"‚ùå V5 API error: {e}")
            
            # –ß–µ—Ä–µ–∑ –±–∞–∑–æ–≤—ã–π exchange client
            if hasattr(self, 'exchange_client') and self.exchange_client:
                try:
                    # –ü–æ–ª—É—á–∞–µ–º –æ—Ç–∫—Ä—ã—Ç—ã–µ –ø–æ–∑–∏—Ü–∏–∏
                    positions = await self.exchange_client.fetch_positions([symbol])
                    
                    for position in positions:
                        if position['symbol'] == symbol and position['contracts'] > 0:
                            # –ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä—É–µ–º –ø–æ–∑–∏—Ü–∏—é
                            if hasattr(self.exchange_client, 'edit_position'):
                                result = await self.exchange_client.edit_position(
                                    symbol=symbol,
                                    params={
                                        'stopLoss': stop_loss,
                                        'takeProfit': take_profit
                                    }
                                )
                                
                                if result:
                                    logger.info(f"‚úÖ SL/TP —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã —á–µ—Ä–µ–∑ exchange_client")
                                    return True
                                    
                except Exception as e:
                    logger.error(f"‚ùå Exchange client error: {e}")
            
            logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å SL/TP –¥–ª—è {symbol}")
            return False
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ SL/TP: {e}")
            return False
    
    # =================================================================
    # –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –ú–ï–¢–û–î–´ –î–õ–Ø –¢–û–†–ì–û–í–õ–ò (–∑–∞–≥–ª—É—à–∫–∏)
    # =================================================================
    
    async def _filter_opportunities(self, opportunities: List[TradingOpportunity]) -> List[TradingOpportunity]:
        """–§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π"""
        return opportunities
    
    async def _rank_all_opportunities(self, opportunities: List[TradingOpportunity]) -> List[TradingOpportunity]:
        """–†–∞–Ω–∂–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π"""
        return opportunities
    
    async def _perform_pre_trade_risk_check(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∏—Å–∫–æ–≤ –ø–µ—Ä–µ–¥ —Ç–æ—Ä–≥–æ–≤–ª–µ–π"""
        return True
    
    async def _update_strategy_performance(self):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π"""
        pass
    
    async def _cleanup_expired_opportunities(self):
        """–û—á–∏—Å—Ç–∫–∞ —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π"""
        pass
    
    async def _trigger_emergency_stop(self, reason: str):
        """–ó–∞–ø—É—Å–∫ —ç–∫—Å—Ç—Ä–µ–Ω–Ω–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–∏"""
        logger.critical(f"üö® –ó–∞–ø—É—Å–∫ —ç–∫—Å—Ç—Ä–µ–Ω–Ω–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–∏: {reason}")
        await self.emergency_stop()
        
    async def _initialize_strategies(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–π - –ü–û–õ–ù–ê–Ø –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø"""
        try:
            logger.info("üéØ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–π...")
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
            try:
                from ..strategies import (
                    MultiIndicatorStrategy,
                    MomentumStrategy, 
                    MeanReversionStrategy,
                    BreakoutStrategy,
                    ScalpingStrategy,
                    #SwingTradingStrategy
                )
                
                # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
                self.available_strategies = {
                    'multi_indicator': MultiIndicatorStrategy,
                    'momentum': MomentumStrategy,
                    'mean_reversion': MeanReversionStrategy,
                    'breakout': BreakoutStrategy,
                    'scalping': ScalpingStrategy,
                    #'swing': SwingTradingStrategy
                }
                
                logger.info(f"‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(self.available_strategies)} —Å—Ç—Ä–∞—Ç–µ–≥–∏–π")
                
            except ImportError as e:
                logger.warning(f"‚ö†Ô∏è –ù–µ –≤—Å–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –¥–æ—Å—Ç—É–ø–Ω—ã: {e}")
                # –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –Ω–∞–±–æ—Ä —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
                self.available_strategies = {}
            
            # –ê–∫—Ç–∏–≤–∏—Ä—É–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ —Å–æ–≥–ª–∞—Å–Ω–æ –≤–µ—Å–∞–º –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
            try:
                strategy_weights = {
                    'multi_indicator': 25.0,
                    'momentum': 20.0,
                    'mean_reversion': 15.0,
                    'breakout': 15.0,
                    'scalping': 10.0,
                    #'swing': 10.0,
                    'ml_prediction': 5.0
                }
                
                # –ï—Å–ª–∏ –µ—Å—Ç—å –≤–µ—Å–∞ –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –∏—Ö
                strategy_weights_config = getattr(config, 'STRATEGY_WEIGHTS', None)
                if strategy_weights_config:
                    # –ü–∞—Ä—Å–∏–º —Å—Ç—Ä–æ–∫—É —Ñ–æ—Ä–º–∞—Ç–∞ "name:weight,name:weight"
                    if isinstance(strategy_weights_config, str):
                        for pair in strategy_weights_config.split(','):
                            if ':' in pair:
                                name, weight = pair.strip().split(':')
                                strategy_weights[name.strip()] = float(weight)
                    elif isinstance(strategy_weights_config, dict):
                        strategy_weights.update(strategy_weights_config)
                
                # –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä—ã –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
                for strategy_name, weight in strategy_weights.items():
                    if weight > 0 and strategy_name in self.available_strategies:
                        try:
                            # –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
                            strategy_class = self.available_strategies[strategy_name]
                            strategy_instance = strategy_class()
                            
                            self.strategy_instances[strategy_name] = strategy_instance
                            
                            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
                            self.strategy_performance[strategy_name] = {
                                'weight': weight,
                                'enabled': True,
                                'total_trades': 0,
                                'winning_trades': 0,
                                'losing_trades': 0,
                                'total_profit': 0.0,
                                'win_rate': 0.0,
                                'last_used': None
                            }
                            
                            logger.info(f"‚úÖ –ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏—è {strategy_name} —Å –≤–µ—Å–æ–º {weight}%")
                            
                        except Exception as e:
                            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ {strategy_name}: {e}")
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Ö–æ—Ç—è –±—ã –æ–¥–Ω–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –∞–∫—Ç–∏–≤–Ω–∞
                if not self.strategy_instances:
                    logger.warning("‚ö†Ô∏è –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å—Ç—Ä–∞—Ç–µ–≥–∏–π, —Å–æ–∑–¥–∞–µ–º –±–∞–∑–æ–≤—É—é")
                    # –°–æ–∑–¥–∞–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é —Å—Ç—Ä–∞—Ç–µ–≥–∏—é-–∑–∞–≥–ª—É—à–∫—É
                    class BasicStrategy:
                        def __init__(self):
                            self.name = 'basic'
                        
                        async def analyze(self, symbol, data):
                            return {'signal': 'HOLD', 'confidence': 0.5}
                    
                    self.strategy_instances['basic'] = BasicStrategy()
                    self.strategy_performance['basic'] = {
                        'weight': 100.0,
                        'enabled': True,
                        'total_trades': 0,
                        'winning_trades': 0,
                        'losing_trades': 0,
                        'total_profit': 0.0,
                        'win_rate': 0.0,
                        'last_used': None
                    }
                
                logger.info(f"‚úÖ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ {len(self.strategy_instances)} —Å—Ç—Ä–∞—Ç–µ–≥–∏–π")
                
                # –õ–æ–≥–∏—Ä—É–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
                active_strategies = [name for name, inst in self.strategy_instances.items()]
                logger.info(f"üìä –ê–∫—Ç–∏–≤–Ω—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏: {', '.join(active_strategies)}")
                
                # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –≤–µ—Å–∞ (—á—Ç–æ–±—ã —Å—É–º–º–∞ –±—ã–ª–∞ 100%)
                total_weight = sum(
                    perf['weight'] 
                    for perf in self.strategy_performance.values() 
                    if perf.get('enabled', True)
                )
                
                if total_weight > 0:
                    for strategy_name in self.strategy_performance:
                        if self.strategy_performance[strategy_name].get('enabled', True):
                            normalized_weight = (
                                self.strategy_performance[strategy_name]['weight'] / total_weight * 100
                            )
                            self.strategy_performance[strategy_name]['normalized_weight'] = normalized_weight
                            logger.debug(
                                f"üìä {strategy_name}: –≤–µ—Å {normalized_weight:.1f}% "
                                f"(–æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π: {self.strategy_performance[strategy_name]['weight']})"
                            )
                
                return True
                
            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π: {e}")
                import traceback
                traceback.print_exc()
                return False
                
        except Exception as e:
            logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π: {e}")
            return False
    
    # ‚úÖ –§–û–ù–û–í–´–ô –¶–ò–ö–õ –æ–±—É—á–µ–Ω–∏—è ML –º–æ–¥–µ–ª–µ–π (–∏–∑ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏):
    async def _ml_training_loop(self):
        """–§–æ–Ω–æ–≤—ã–π —Ü–∏–∫–ª –æ–±—É—á–µ–Ω–∏—è ML –º–æ–¥–µ–ª–µ–π"""
        while not self._stop_event.is_set():
            try:
                # –ñ–¥–µ–º –∑–∞–¥–∞–Ω–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª
                interval = getattr(self.config, 'ML_MODEL_RETRAIN_INTERVAL', 86400)  # 24 —á–∞—Å–∞
                await asyncio.sleep(interval)
                
                if self._stop_event.is_set():
                    break
                
                logger.info("üéì –ó–∞–ø—É—Å–∫ –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏—è ML –º–æ–¥–µ–ª–µ–π...")
                
                # –û–±—É—á–∞–µ–º –º–æ–¥–µ–ª–∏ –¥–ª—è –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–∞—Ä
                if hasattr(self, 'ml_system') and self.ml_system and hasattr(self.ml_system, 'trainer'):
                    for symbol in list(self.active_pairs)[:5]:  # –ú–∞–∫—Å–∏–º—É–º 5 –ø–∞—Ä
                        try:
                            logger.info(f"üéì –û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏ –¥–ª—è {symbol}...")
                            result = await self.ml_system.trainer.train_symbol_model(symbol)
                            
                            if result.get('success'):
                                logger.info(f"‚úÖ –ú–æ–¥–µ–ª—å –¥–ª—è {symbol} –æ–±—É—á–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ")
                            else:
                                logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—É—á–∏—Ç—å –º–æ–¥–µ–ª—å –¥–ª—è {symbol}")
                            
                            # –ü–∞—É–∑–∞ –º–µ–∂–¥—É –æ–±—É—á–µ–Ω–∏—è–º–∏
                            await asyncio.sleep(300)  # 5 –º–∏–Ω—É—Ç
                            
                        except Exception as e:
                            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—É—á–µ–Ω–∏—è –¥–ª—è {symbol}: {e}")
                
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ ML training loop: {e}")
    
    # =================================================================
    # –£–ü–†–ê–í–õ–ï–ù–ò–ï –ó–î–û–†–û–í–¨–ï–ú –°–ò–°–¢–ï–ú–´
    # =================================================================
    
    async def _perform_health_check(self) -> Dict[str, Any]:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è –≤—Å–µ–π —Å–∏—Å—Ç–µ–º—ã"""
        try:
            health_info = {
                'timestamp': datetime.utcnow().isoformat(),
                'overall_healthy': True,
                'components': {},
                'tasks': {},
                'system': {},
                'alerts': []
            }
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
            for name, comp in self.components.items():
                is_healthy = comp.status == ComponentStatus.READY
                if comp.last_heartbeat:
                    time_since_heartbeat = (datetime.utcnow() - comp.last_heartbeat).total_seconds()
                    is_healthy = is_healthy and time_since_heartbeat < comp.health_check_interval * 2
                
                health_info['components'][name] = {
                    'status': comp.status.value,
                    'healthy': is_healthy,
                    'last_heartbeat': comp.last_heartbeat.isoformat() if comp.last_heartbeat else None,
                    'restart_count': comp.restart_count
                }
                
                if not is_healthy and comp.is_critical:
                    health_info['overall_healthy'] = False
                    health_info['alerts'].append(f"Critical component {name} is unhealthy")
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–¥–∞—á
            for name, task in self.tasks.items():
                task_healthy = task and not task.done()
                health_info['tasks'][name] = {
                    'running': task_healthy,
                    'health': self.task_health.get(name, 'unknown'),
                    'done': task.done() if task else True
                }
                
                if not task_healthy:
                    health_info['alerts'].append(f"Task {name} is not running")
            
            # –°–∏—Å—Ç–µ–º–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏
            try:
                process = psutil.Process()
                memory_info = process.memory_info()
                
                health_info['system'] = {
                    'memory_usage_mb': memory_info.rss / 1024 / 1024,
                    'cpu_percent': process.cpu_percent(),
                    'open_files': len(process.open_files()),
                    'threads': process.num_threads()
                }
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç—ã
                if health_info['system']['memory_usage_mb'] > 2048:  # 2GB
                    health_info['alerts'].append("High memory usage detected")
                
            except Exception as e:
                health_info['system']['error'] = str(e)
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ—Ä–≥–æ–≤—ã—Ö –ª–∏–º–∏—Ç–æ–≤
            if self.trades_today >= config.MAX_DAILY_TRADES * 0.9:
                health_info['alerts'].append("Approaching daily trade limit")
            
            if len(self.positions) >= config.MAX_POSITIONS * 0.9:
                health_info['alerts'].append("Approaching position limit")
            
            # –û–±—â–µ–µ –∑–¥–æ—Ä–æ–≤—å–µ
            if health_info['alerts']:
                health_info['overall_healthy'] = False
            
            self.last_health_check_time = datetime.utcnow().isoformat()
            return health_info
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è: {e}")
            return {
                'timestamp': datetime.utcnow().isoformat(),
                'overall_healthy': False,
                'error': str(e)
            }
    
    # =================================================================
    # –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –ú–ï–¢–û–î–´ (–∑–∞–≥–ª—É—à–∫–∏ –¥–ª—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏)
    # =================================================================
    
    async def _setup_signal_handlers(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–∏–≥–Ω–∞–ª–æ–≤"""
        pass
    
    async def _validate_configuration(self) -> bool:
        """–í–∞–ª–∏–¥–∞—Ü–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏"""
        return True
    
    async def _connect_exchange(self) -> bool:
        """–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–∏—Ä–∂–µ"""
        return True
    
    async def _load_historical_data(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö"""
        pass
    
    async def _perform_initial_market_analysis(self):
        """–ù–∞—á–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —Ä—ã–Ω–∫–∞"""
        pass
    
    async def _setup_monitoring_system(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å–∏—Å—Ç–µ–º—ã –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
        pass
    
    async def _start_websocket_connections(self):
        """–ó–∞–ø—É—Å–∫ WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π"""
        pass
    
    async def _send_startup_notification(self):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –∑–∞–ø—É—Å–∫–µ"""
        pass
    
    async def _log_startup_statistics(self):
        """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∑–∞–ø—É—Å–∫–∞"""
        pass
    
    async def _save_current_state(self):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è"""
        pass
    
    async def _close_all_positions_safely(self):
        """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ –≤—Å–µ—Ö –ø–æ–∑–∏—Ü–∏–π"""
        pass
    
    async def _cancel_all_orders(self):
        """–û—Ç–º–µ–Ω–∞ –≤—Å–µ—Ö –æ—Ä–¥–µ—Ä–æ–≤"""
        pass
    
    async def _stop_all_tasks(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤—Å–µ—Ö –∑–∞–¥–∞—á"""
        for task_name, task in self.tasks.items():
            if task and not task.done():
                task.cancel()
                try:
                    await asyncio.wait_for(task, timeout=5.0)
                except asyncio.TimeoutError:
                    logger.warning(f"‚ö†Ô∏è –¢–∞–π–º–∞—É—Ç –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –∑–∞–¥–∞—á–∏: {task_name}")
                except asyncio.CancelledError:
                    pass
    
    async def _close_websocket_connections(self):
        """–ó–∞–∫—Ä—ã—Ç–∏–µ WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π"""
        pass
    
    async def _stop_ml_system(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ ML —Å–∏—Å—Ç–µ–º—ã"""
        pass
    
    async def _export_final_data(self):
        """–≠–∫—Å–ø–æ—Ä—Ç —Ñ–∏–Ω–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö"""
        pass
    
    async def _disconnect_exchange(self):
        """–û—Ç–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç –±–∏—Ä–∂–∏"""
        pass
    
    async def _close_database_connections(self):
        """–ó–∞–∫—Ä—ã—Ç–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π —Å –ë–î"""
        pass
    
    async def _cleanup_caches(self):
        """–û—á–∏—Å—Ç–∫–∞ –∫—ç—à–µ–π"""
        self.market_data_cache.clear()
        self.ml_predictions.clear()
        self.current_opportunities.clear()
    
    async def _send_shutdown_notification(self, old_status):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± –æ—Å—Ç–∞–Ω–æ–≤–∫–µ"""
        pass
    
    async def _send_error_notification(self, error_msg):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–µ"""
        pass
    
    async def _cancel_pending_orders(self):
        """–û—Ç–º–µ–Ω–∞ –æ–∂–∏–¥–∞—é—â–∏—Ö –æ—Ä–¥–µ—Ä–æ–≤"""
        pass
    
    async def _send_pause_notification(self):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –ø–∞—É–∑–µ"""
        pass
    
    async def _refresh_market_data(self):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä—ã–Ω–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö"""
        pass
    
    async def _send_resume_notification(self):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –≤–æ–∑–æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏"""
        pass
    
    async def _emergency_close_all_positions(self):
        """–≠–∫—Å—Ç—Ä–µ–Ω–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ –≤—Å–µ—Ö –ø–æ–∑–∏—Ü–∏–π"""
        pass
    
    async def _send_emergency_notification(self):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —ç–∫—Å—Ç—Ä–µ–Ω–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è"""
        pass
    
    def _get_best_strategy(self) -> Optional[str]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ª—É—á—à–µ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏"""
        if not self.strategy_performance:
            return None
        
        best_strategy = max(
            self.strategy_performance.items(),
            key=lambda x: x[1].get('win_rate', 0)
        )
        return best_strategy[0]
    
    # =================================================================
    # –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –¶–ò–ö–õ–´ (–∑–∞–≥–ª—É—à–∫–∏)
    # =================================================================
    
    async def _market_monitoring_loop(self):
        """–¶–∏–∫–ª –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Ä—ã–Ω–∫–∞"""
        while not self._stop_event.is_set():
            try:
                await self._pause_event.wait()
                # –õ–æ–≥–∏–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Ä—ã–Ω–∫–∞
                await asyncio.sleep(300)  # 5 –º–∏–Ω—É—Ç
            except asyncio.CancelledError:
                break
    
    async def _pair_discovery_loop(self):
        """–¶–∏–∫–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä"""
        while not self._stop_event.is_set():
            try:
                await self._pause_event.wait()
                # –õ–æ–≥–∏–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–∞—Ä
                await asyncio.sleep(config.PAIR_DISCOVERY_INTERVAL_HOURS * 3600)
            except asyncio.CancelledError:
                break
    
    async def _position_management_loop(self):
        """–¶–∏–∫–ª —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏—è–º–∏"""
        while not self._stop_event.is_set():
            try:
                await self._pause_event.wait()
                # –õ–æ–≥–∏–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏—è–º–∏
                await asyncio.sleep(30)
            except asyncio.CancelledError:
                break
    
    async def _risk_monitoring_loop(self):
        """–¶–∏–∫–ª –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Ä–∏—Å–∫–æ–≤"""
        while not self._stop_event.is_set():
            try:
                await self._pause_event.wait()
                # –õ–æ–≥–∏–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Ä–∏—Å–∫–æ–≤
                await asyncio.sleep(60)
            except asyncio.CancelledError:
                break
    
    async def _health_monitoring_loop(self):
        """–¶–∏–∫–ª –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∑–¥–æ—Ä–æ–≤—å—è"""
        while not self._stop_event.is_set():
            try:
                await self._pause_event.wait()
                health_status = await self._perform_health_check()
                # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è
                await asyncio.sleep(300)  # 5 –º–∏–Ω—É—Ç
            except asyncio.CancelledError:
                break
    
    async def _performance_monitoring_loop(self):
        """–¶–∏–∫–ª –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏"""
        while not self._stop_event.is_set():
            try:
                await self._pause_event.wait()
                # –õ–æ–≥–∏–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
                await asyncio.sleep(60)
            except asyncio.CancelledError:
                break
    
    async def _data_export_loop(self):
        """–¶–∏–∫–ª —ç–∫—Å–ø–æ—Ä—Ç–∞ –¥–∞–Ω–Ω—ã—Ö"""
        while not self._stop_event.is_set():
            try:
                await self._pause_event.wait()
                # –õ–æ–≥–∏–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞ –¥–∞–Ω–Ω—ã—Ö
                await asyncio.sleep(3600)  # 1 —á–∞—Å
            except asyncio.CancelledError:
                break
    
    async def _ml_prediction_loop(self):
        """–¶–∏–∫–ª ML –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π"""
        while not self._stop_event.is_set():
            try:
                await self._pause_event.wait()
                # –õ–æ–≥–∏–∫–∞ ML –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π
                await asyncio.sleep(300)  # 5 –º–∏–Ω—É—Ç
            except asyncio.CancelledError:
                break
    
    async def _news_collection_loop(self):
        """–¶–∏–∫–ª —Å–±–æ—Ä–∞ –Ω–æ–≤–æ—Å—Ç–µ–π"""
        while not self._stop_event.is_set():
            try:
                await self._pause_event.wait()
                # –õ–æ–≥–∏–∫–∞ —Å–±–æ—Ä–∞ –Ω–æ–≤–æ—Å—Ç–µ–π
                await asyncio.sleep(1800)  # 30 –º–∏–Ω—É—Ç
            except asyncio.CancelledError:
                break
    
    async def _sentiment_analysis_loop(self):
        """–¶–∏–∫–ª –∞–Ω–∞–ª–∏–∑–∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–π"""
        while not self._stop_event.is_set():
            try:
                await self._pause_event.wait()
                # –õ–æ–≥–∏–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–π
                await asyncio.sleep(600)  # 10 –º–∏–Ω—É—Ç
            except asyncio.CancelledError:
                break
    
    async def _event_processing_loop(self):
        """–¶–∏–∫–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–±—ã—Ç–∏–π"""
        while not self._stop_event.is_set():
            try:
                await self._pause_event.wait()
                # –õ–æ–≥–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–±—ã—Ç–∏–π
                await asyncio.sleep(1)
            except asyncio.CancelledError:
                break
    
    async def _init_config_validator(self) -> bool:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏"""
        try:
            # –í–∞–ª–∏–¥–∏—Ä—É–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
            if not config.validate_config():
                return False
            
            logger.info("‚úÖ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –≤–∞–ª–∏–¥–Ω–∞")
            return True
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
            return False
    
    async def _init_exchange_client(self):
        """‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º EnhancedUnifiedExchangeClient"""
        try:
            # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –Ω—É–∂–Ω—ã–µ –∫–ª–∞—Å—Å—ã
            from ..exchange import get_enhanced_exchange_client, BYBIT_INTEGRATION_AVAILABLE
            
            if BYBIT_INTEGRATION_AVAILABLE:
                logger.info("üöÄ –ò—Å–ø–æ–ª—å–∑—É–µ–º EnhancedUnifiedExchangeClient")
                self.exchange_client = get_enhanced_exchange_client()
            else:
                logger.warning("‚ö†Ô∏è Enhanced –∫–ª–∏–µ–Ω—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –±–∞–∑–æ–≤—ã–π")
                from ..exchange import UnifiedExchangeClient
                self.exchange_client = UnifiedExchangeClient()
            
            # –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –±–∏—Ä–∂–µ
            exchange_name = getattr(config, 'DEFAULT_EXCHANGE', 'bybit')
            testnet = getattr(config, 'BYBIT_TESTNET', True)
            
            logger.info(f"üîó –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ {exchange_name} (testnet={testnet})...")
            success = await self.exchange_client.connect(exchange_name, testnet)
            
            if success:
                logger.info("‚úÖ Exchange –∫–ª–∏–µ–Ω—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
                
                # –î–ª—è Enhanced –∫–ª–∏–µ–Ω—Ç–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
                if hasattr(self.exchange_client, 'initialize'):
                    await self.exchange_client.initialize()
                    
                return True
            else:
                logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ –±–∏—Ä–∂–µ")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ exchange –∫–ª–∏–µ–Ω—Ç–∞: {e}")
            return False
    
    async def _init_data_collector(self) -> bool:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–±–æ—Ä—â–∏–∫–∞ –¥–∞–Ω–Ω—ã—Ö - –†–ï–ê–õ–¨–ù–´–ô"""
        try:
            # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ä–µ–∞–ª—å–Ω—ã–π DataCollector
            from ..data.data_collector import DataCollector
            
            # –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä —Å exchange_client –∏ —Å–µ—Å—Å–∏–µ–π –ë–î
            self.data_collector = DataCollector(
                self.exchange_client, 
                SessionLocal  # –ü–µ—Ä–µ–¥–∞–µ–º —Ñ–∞–±—Ä–∏–∫—É —Å–µ—Å—Å–∏–π, –∞ –Ω–µ self.db
            )
            
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ –ø–∞—Ä—ã –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
            if hasattr(self, 'active_pairs') and self.active_pairs:
                self.data_collector.set_active_pairs(list(self.active_pairs))
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º —Å–±–æ—Ä—â–∏–∫
            await self.data_collector.start()
            
            logger.info("‚úÖ DataCollector –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –∏ –∑–∞–ø—É—â–µ–Ω")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ DataCollector: {e}")
            return False
    
    async def _init_market_analyzer(self) -> bool:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä–∞ —Ä—ã–Ω–∫–∞"""
        try:
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä —Ä—ã–Ω–∫–∞ (–∑–∞–≥–ª—É—à–∫–∞)
            from ..analysis.market_analyzer import MarketAnalyzer
            self.market_analyzer = MarketAnalyzer()
            logger.info("‚úÖ –ê–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä —Ä—ã–Ω–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            return True
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä–∞ —Ä—ã–Ω–∫–∞: {e}")
            return False
    
    async def _init_risk_manager(self) -> bool:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞ —Ä–∏—Å–∫–æ–≤"""
        try:
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä —Ä–∏—Å–∫–æ–≤ (–∑–∞–≥–ª—É—à–∫–∞)
            logger.info("‚úÖ –ú–µ–Ω–µ–¥–∂–µ—Ä —Ä–∏—Å–∫–æ–≤ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            return True
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –º–µ–Ω–µ–¥–∂–µ—Ä–∞ —Ä–∏—Å–∫–æ–≤: {e}")
            return False
    
    async def _init_portfolio_manager(self) -> bool:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –ø–æ—Ä—Ç—Ñ–µ–ª—è"""
        try:
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä –ø–æ—Ä—Ç—Ñ–µ–ª—è (–∑–∞–≥–ª—É—à–∫–∞)
            logger.info("‚úÖ –ú–µ–Ω–µ–¥–∂–µ—Ä –ø–æ—Ä—Ç—Ñ–µ–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            return True
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –ø–æ—Ä—Ç—Ñ–µ–ª—è: {e}")
            return False
    
    async def _init_strategy_factory(self) -> bool:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ñ–∞–±—Ä–∏–∫–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π"""
        try:
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ñ–∞–±—Ä–∏–∫—É —Å—Ç—Ä–∞—Ç–µ–≥–∏–π (–∑–∞–≥–ª—É—à–∫–∞)
            logger.info("‚úÖ –§–∞–±—Ä–∏–∫–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
            return True
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Ñ–∞–±—Ä–∏–∫–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π: {e}")
            return False
    
    async def _init_trader(self) -> bool:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è —Å–¥–µ–ª–æ–∫"""
        try:
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è —Å–¥–µ–ª–æ–∫ (–∑–∞–≥–ª—É—à–∫–∞)
            logger.info("‚úÖ –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å —Å–¥–µ–ª–æ–∫ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            return True
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è —Å–¥–µ–ª–æ–∫: {e}")
            return False
    
    async def _init_notifier(self) -> bool:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π"""
        try:
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–∏—Å—Ç–µ–º—É —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π (–∑–∞–≥–ª—É—à–∫–∞)
            if config.TELEGRAM_ENABLED and config.TELEGRAM_BOT_TOKEN:
                logger.info("‚úÖ –°–∏—Å—Ç–µ–º–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π Telegram –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
            else:
                logger.info("‚ö†Ô∏è Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ—Ç–∫–ª—é—á–µ–Ω—ã")
            return True
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π: {e}")
            return False
    
    # ‚úÖ –ù–û–í–´–ô –ú–ï–¢–û–î –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ ML —Å–∏—Å—Ç–µ–º—ã (–ó–ê–ú–ï–ù–ê –°–£–©–ï–°–¢–í–£–Æ–©–ï–ì–û):
    async def _init_ml_system(self) -> bool:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã –º–∞—à–∏–Ω–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è"""
        try:
            if not getattr(self.config, 'ENABLE_MACHINE_LEARNING', False):
                logger.info("‚ÑπÔ∏è –ú–∞—à–∏–Ω–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏")
                return False
            
            # –°–æ–∑–¥–∞–µ–º –∫–æ–º–ø–ª–µ–∫—Å–Ω—É—é ML —Å–∏—Å—Ç–µ–º—É
            from ..ml.models.direction_classifier import DirectionClassifier
            from ..ml.models.price_regressor import PriceLevelRegressor
            from ..ml.models.rl_agent import TradingRLAgent
            from ..ml.features.feature_engineering import FeatureEngineer
            from ..ml.training.trainer import MLTrainer
            
            class MLSystem:
                def __init__(self):
                    self.direction_classifier = DirectionClassifier()
                    self.price_regressor = PriceLevelRegressor()
                    self.rl_agent = TradingRLAgent()
                    self.feature_engineer = FeatureEngineer()
                    self.trainer = MLTrainer()
                    self.is_initialized = False
                    
                async def initialize(self):
                    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤—Å–µ—Ö ML –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤"""
                    try:
                        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º trainer
                        await self.trainer.initialize()
                        
                        # –ó–∞–≥—Ä—É–∂–∞–µ–º –º–æ–¥–µ–ª–∏ –µ—Å–ª–∏ –µ—Å—Ç—å
                        await self.load_models()
                        
                        self.is_initialized = True
                        logger.info("‚úÖ ML —Å–∏—Å—Ç–µ–º–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
                    except Exception as e:
                        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ ML: {e}")
                        self.is_initialized = False
                    
                async def load_models(self):
                    """–ó–∞–≥—Ä—É–∑–∫–∞ –æ–±—É—á–µ–Ω–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π"""
                    try:
                        # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π
                        available_models = self.trainer.list_available_models()
                        
                        if available_models:
                            logger.info(f"üìä –ù–∞–π–¥–µ–Ω–æ {len(available_models)} –æ–±—É—á–µ–Ω–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π")
                            # –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ –º–æ–¥–µ–ª–∏ –¥–ª—è –æ—Å–Ω–æ–≤–Ω—ã—Ö –ø–∞—Ä
                            for model_info in available_models[:5]:  # –ú–∞–∫—Å–∏–º—É–º 5 –º–æ–¥–µ–ª–µ–π
                                logger.info(f"üìà –ó–∞–≥—Ä—É–∂–∞–µ–º –º–æ–¥–µ–ª—å –¥–ª—è {model_info['symbol']}")
                        else:
                            logger.warning("‚ö†Ô∏è –û–±—É—á–µ–Ω–Ω—ã–µ –º–æ–¥–µ–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã, –±—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã –±–∞–∑–æ–≤—ã–µ")
                    except Exception as e:
                        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–µ–π: {e}")
                
                async def predict_direction(self, symbol: str, df: pd.DataFrame) -> Dict[str, Any]:
                    """–ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–≤–∏–∂–µ–Ω–∏—è —Ü–µ–Ω—ã"""
                    try:
                        # –ò–∑–≤–ª–µ–∫–∞–µ–º –ø—Ä–∏–∑–Ω–∞–∫–∏
                        features = await self.feature_engineer.extract_features(symbol, df)
                        
                        # –ü–æ–ª—É—á–∞–µ–º –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
                        prediction = self.direction_classifier.predict(features)
                        
                        return {
                            'action': prediction['direction_labels'][0],  # BUY/SELL/HOLD
                            'confidence': prediction['confidence'][0],
                            'probabilities': prediction['probabilities'][0],
                            'features': features.to_dict() if hasattr(features, 'to_dict') else {},
                            'model_type': 'ensemble',
                            'forecast_horizon': 5
                        }
                    except Exception as e:
                        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è: {e}")
                        return None
                
                async def predict_price_levels(self, symbol: str, df: pd.DataFrame) -> Dict[str, Any]:
                    """–ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ —É—Ä–æ–≤–Ω–µ–π —Ü–µ–Ω—ã"""
                    try:
                        # –ò—Å–ø–æ–ª—å–∑—É–µ–º price regressor
                        features = await self.feature_engineer.extract_features(symbol, df)
                        levels = self.price_regressor.predict_levels(features)
                        
                        current_price = df['close'].iloc[-1]
                        
                        return {
                            'support': levels.get('support', current_price * 0.98),
                            'resistance': levels.get('resistance', current_price * 1.02),
                            'pivot': levels.get('pivot', current_price),
                            'confidence': levels.get('confidence', 0.5),
                            'targets': {
                                'target_1': current_price * 1.01,
                                'target_2': current_price * 1.02,
                                'target_3': current_price * 1.03
                            }
                        }
                    except Exception as e:
                        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è —É—Ä–æ–≤–Ω–µ–π: {e}")
                        return {'support': 0, 'resistance': 0}
                
                async def get_rl_recommendation(self, symbol: str, df: pd.DataFrame) -> Dict[str, Any]:
                    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –æ—Ç RL –∞–≥–µ–Ω—Ç–∞"""
                    try:
                        # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
                        state = self._prepare_rl_state(df)
                        
                        # –ü–æ–ª—É—á–∞–µ–º –¥–µ–π—Å—Ç–≤–∏–µ
                        action_data = self.rl_agent.predict(state)
                        
                        return {
                            'action': action_data['action_name'],  # BUY/HOLD/SELL
                            'confidence': action_data['confidence'],
                            'q_values': action_data.get('q_values', [])
                        }
                    except Exception as e:
                        logger.error(f"‚ùå –û—à–∏–±–∫–∞ RL —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏: {e}")
                        return None
                
                def _prepare_rl_state(self, df: pd.DataFrame) -> np.ndarray:
                    """–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è RL –∞–≥–µ–Ω—Ç–∞"""
                    # –ü—Ä–æ—Å—Ç–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–∑ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π
                    row = df.iloc[-1]
                    state = np.array([
                        row.get('rsi', 50) / 100.0,
                        row.get('macd', 0) / 100.0,
                        row.get('bb_position', 0.5),
                        row.get('volume_ratio', 1.0),
                        row.get('price_change', 0) / 10.0,
                        df['close'].pct_change().iloc[-5:].mean() * 100,  # 5-–ø–µ—Ä–∏–æ–¥ momentum
                        df['volume'].iloc[-5:].mean() / df['volume'].iloc[-20:].mean(),  # Volume ratio
                        0.5  # Portfolio state placeholder
                    ])
                    return state
            
            # –°–æ–∑–¥–∞–µ–º –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º ML —Å–∏—Å—Ç–µ–º—É
            self.ml_system = MLSystem()
            await self.ml_system.initialize()
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º —Ñ–æ–Ω–æ–≤–æ–µ –æ–±—É—á–µ–Ω–∏–µ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
            if getattr(self.config, 'ENABLE_ML_TRAINING', False):
                asyncio.create_task(self._ml_training_loop())
            
            logger.info("‚úÖ ML —Å–∏—Å—Ç–µ–º–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ –∏ –≥–æ—Ç–æ–≤–∞ –∫ —Ä–∞–±–æ—Ç–µ")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ ML —Å–∏—Å—Ç–µ–º—ã: {e}")
            return False
    
    async def _init_news_analyzer(self) -> bool:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä–∞ –Ω–æ–≤–æ—Å—Ç–µ–π"""
        try:
            if not config.ENABLE_NEWS_ANALYSIS:
                logger.info("‚ö†Ô∏è –ê–Ω–∞–ª–∏–∑ –Ω–æ–≤–æ—Å—Ç–µ–π –æ—Ç–∫–ª—é—á–µ–Ω")
                return True
                
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –Ω–æ–≤–æ—Å—Ç–µ–π (–∑–∞–≥–ª—É—à–∫–∞)
            logger.info("‚úÖ –ê–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –Ω–æ–≤–æ—Å—Ç–µ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            return True
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä–∞ –Ω–æ–≤–æ—Å—Ç–µ–π: {e}")
            return False
    
    async def _init_websocket_manager(self) -> bool:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞ WebSocket"""
        try:
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º WebSocket –º–µ–Ω–µ–¥–∂–µ—Ä (–∑–∞–≥–ª—É—à–∫–∞)
            logger.info("‚úÖ –ú–µ–Ω–µ–¥–∂–µ—Ä WebSocket –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            return True
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ WebSocket –º–µ–Ω–µ–¥–∂–µ—Ä–∞: {e}")
            return False
    
    async def _init_export_manager(self) -> bool:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        try:
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä —ç–∫—Å–ø–æ—Ä—Ç–∞ (–∑–∞–≥–ª—É—à–∫–∞)
            logger.info("‚úÖ –ú–µ–Ω–µ–¥–∂–µ—Ä —ç–∫—Å–ø–æ—Ä—Ç–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            return True
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –º–µ–Ω–µ–¥–∂–µ—Ä–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞: {e}")
            return False
    
    async def _init_health_monitor(self) -> bool:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–Ω–∏—Ç–æ—Ä–∞ –∑–¥–æ—Ä–æ–≤—å—è"""
        try:
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –º–æ–Ω–∏—Ç–æ—Ä –∑–¥–æ—Ä–æ–≤—å—è (–∑–∞–≥–ª—É—à–∫–∞)
            logger.info("‚úÖ –ú–æ–Ω–∏—Ç–æ—Ä –∑–¥–æ—Ä–æ–≤—å—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            return True
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –º–æ–Ω–∏—Ç–æ—Ä–∞ –∑–¥–æ—Ä–æ–≤—å—è: {e}")
            return False
    
    # =================================================================
    # –ú–ï–¢–û–î–´ –î–õ–Ø –°–û–í–ú–ï–°–¢–ò–ú–û–°–¢–ò (—Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ)
    # =================================================================
    
    async def update_pairs(self, pairs: List[str]) -> None:
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä (–¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)"""
        self.trading_pairs = pairs
        # –û–±–Ω–æ–≤–ª—è–µ–º —Ç–∞–∫–∂–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –ø–∞—Ä—ã
        self.active_pairs = pairs[:config.MAX_TRADING_PAIRS]
        logger.info(f"üìä –û–±–Ω–æ–≤–ª–µ–Ω—ã —Ç–æ—Ä–≥–æ–≤—ã–µ –ø–∞—Ä—ã: {len(pairs)}")
    
    def __repr__(self) -> str:
        """–°—Ç—Ä–æ–∫–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏"""
        return (
            f"BotManager(status={self.status.value}, "
            f"pairs={len(self.active_pairs)}, "
            f"positions={len(self.positions)}, "
            f"cycles={self.cycles_count}, "
            f"uptime={self.start_time})"
        )
    
    async def initialize_enhanced_exchange(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è enhanced exchange –∫–ª–∏–µ–Ω—Ç–∞ - –ò–°–ü–†–ê–í–õ–ï–ù–û"""
        try:
            logger.info("üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è enhanced exchange...")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å V5 –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π
            from ..exchange import check_bybit_v5_capabilities
            v5_capabilities = check_bybit_v5_capabilities()
            logger.info(f"üîç V5 –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏: {v5_capabilities}")
            
            if not v5_capabilities.get('enhanced_features', False):
                logger.warning("‚ö†Ô∏è Enhanced –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã")
                return False
            
            # –°–æ–∑–¥–∞–µ–º enhanced –∫–ª–∏–µ–Ω—Ç
            from ..exchange import get_enhanced_exchange_client
            self.enhanced_exchange_client = get_enhanced_exchange_client()
            
            # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é –±–æ–ª–µ–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ
            if hasattr(self.enhanced_exchange_client, 'initialize'):
                success = await self.enhanced_exchange_client.initialize()
                if success:
                    logger.info("‚úÖ Enhanced exchange –∫–ª–∏–µ–Ω—Ç –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω")
                    
                    # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ health_check
                    try:
                        if hasattr(self.enhanced_exchange_client, 'health_check'):
                            health_status = await self.enhanced_exchange_client.health_check()
                            status = health_status.get('overall_status', 'unknown')
                            logger.info(f"üîç Enhanced –∫–ª–∏–µ–Ω—Ç —Å—Ç–∞—Ç—É—Å: {status}")
                        else:
                            logger.info("üîç Enhanced –∫–ª–∏–µ–Ω—Ç —Å—Ç–∞—Ç—É—Å: initialized (no health_check)")
                    except Exception as health_error:
                        logger.warning(f"‚ö†Ô∏è Health check –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: {health_error}")
                        # –ù–µ —Å—á–∏—Ç–∞–µ–º —ç—Ç–æ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–π –æ—à–∏–±–∫–æ–π
                    
                    self.v5_integration_enabled = True
                    return True
                else:
                    logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å enhanced –∫–ª–∏–µ–Ω—Ç")
                    return False
            else:
                # –ï—Å–ª–∏ –Ω–µ—Ç –º–µ—Ç–æ–¥–∞ initialize - —Å—á–∏—Ç–∞–µ–º —á—Ç–æ —É–∂–µ –≥–æ—Ç–æ–≤
                logger.info("‚úÖ Enhanced –∫–ª–∏–µ–Ω—Ç –≥–æ—Ç–æ–≤ (–±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏)")
                self.v5_integration_enabled = True
                return True
                
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ enhanced –∫–ª–∏–µ–Ω—Ç–∞: {e}")
            return False
    
    async def get_market_data_enhanced(self, symbol: str) -> Optional[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ä—ã–Ω–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö —á–µ—Ä–µ–∑ enhanced API"""
        try:
            # –ü—Ä–æ–±—É–µ–º enhanced –∫–ª–∏–µ–Ω—Ç
            if self.v5_integration_enabled and self.enhanced_exchange_client:
                data = await self.enhanced_exchange_client.get_market_data(symbol)
                if data:
                    # –õ–æ–≥–∏—Ä—É–µ–º –∏—Å—Ç–æ—á–Ω–∏–∫ –¥–∞–Ω–Ω—ã—Ö
                    source = data.get('source', 'v5' if 'source' not in data else data['source'])
                    logger.debug(f"üìä {symbol} –¥–∞–Ω–Ω—ã–µ –∏–∑ {source}")
                    return data
                else:
                    logger.debug(f"‚ö†Ô∏è Enhanced API –Ω–µ –≤–µ—Ä–Ω—É–ª –¥–∞–Ω–Ω—ã–µ –¥–ª—è {symbol}")
            
            # Fallback –∫ legacy exchange
            if self.exchange_client and hasattr(self.exchange_client, 'get_ticker'):
                legacy_data = await self.exchange_client.get_ticker(symbol)
                if legacy_data:
                    # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∫ enhanced —Ñ–æ—Ä–º–∞—Ç—É
                    return {
                        'symbol': symbol,
                        'timestamp': int(datetime.now().timestamp() * 1000),
                        'price': legacy_data.get('price', 0),
                        'bid': legacy_data.get('bid', 0),
                        'ask': legacy_data.get('ask', 0),
                        'volume': legacy_data.get('volume', 0),
                        'change': legacy_data.get('change_percent_24h', 0),
                        'source': 'legacy'
                    }
            
            logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è {symbol}")
            return None
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö {symbol}: {e}")
            return None
    
    async def get_account_balance_enhanced(self) -> Optional[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ —á–µ—Ä–µ–∑ enhanced API"""
        try:
            # –ü—Ä–æ–±—É–µ–º enhanced –∫–ª–∏–µ–Ω—Ç
            if self.v5_integration_enabled and self.enhanced_exchange_client:
                balance = await self.enhanced_exchange_client.get_account_info()
                if balance:
                    logger.debug(f"üí∞ –ë–∞–ª–∞–Ω—Å –∏–∑ {balance.get('source', 'v5')}")
                    return balance
            
            # Fallback –∫ legacy
            if self.exchange_client and hasattr(self.exchange_client, 'get_balance'):
                legacy_balance = await self.exchange_client.get_balance()
                if legacy_balance and 'error' not in legacy_balance:
                    return legacy_balance
            
            return None
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞: {e}")
            return None
    
    async def monitor_enhanced_health(self):
        """–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Å–æ—Å—Ç–æ—è–Ω–∏—è enhanced —Å–∏—Å—Ç–µ–º—ã"""
        try:
            if self.v5_integration_enabled and self.enhanced_exchange_client:
                health = await self.enhanced_exchange_client.health_check()
                
                # –õ–æ–≥–∏—Ä—É–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∫–∞–∂–¥—ã–µ 10 –º–∏–Ω—É—Ç
                if hasattr(self, '_last_health_log'):
                    if datetime.now() - self._last_health_log > timedelta(minutes=10):
                        self._log_health_stats(health)
                        self._last_health_log = datetime.now()
                else:
                    self._last_health_log = datetime.now()
                    self._log_health_stats(health)
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–µ–≥—Ä–∞–¥–∞—Ü–∏—é
                if health['overall_status'] == 'degraded':
                    logger.warning("‚ö†Ô∏è Enhanced —Å–∏—Å—Ç–µ–º–∞ –≤ —Ä–µ–∂–∏–º–µ –¥–µ–≥—Ä–∞–¥–∞—Ü–∏–∏")
                
                return health
            
            return None
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ health: {e}")
            return None
    
    def _log_health_stats(self, health: Dict):
        """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ health"""
        try:
            stats = health.get('statistics', {})
            logger.info("üìä Enhanced —Å–∏—Å—Ç–µ–º–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:")
            logger.info(f"   V5 –∑–∞–ø—Ä–æ—Å—ã: {stats.get('v5_requests', 0)}")
            logger.info(f"   Legacy –∑–∞–ø—Ä–æ—Å—ã: {stats.get('legacy_requests', 0)}")
            logger.info(f"   –û–±—â–∏–π —Å—Ç–∞—Ç—É—Å: {health.get('overall_status', 'unknown')}")
            
            # –ú–∏–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π —Å—Ç–∞—Ç—É—Å
            if hasattr(self.enhanced_exchange_client, 'get_migration_status'):
                migration = self.enhanced_exchange_client.get_migration_status()
                logger.info(f"   V5 –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: {migration.get('v5_usage_percentage', 0):.1f}%")
                
        except Exception as e:
            logger.debug(f"–û—à–∏–±–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è health stats: {e}")


# =========================================================================
# === –°–û–ó–î–ê–ù–ò–ï –ì–õ–û–ë–ê–õ–¨–ù–û–ì–û –≠–ö–ó–ï–ú–ü–õ–Ø–†–ê ===
# =========================================================================

# –°–æ–∑–¥–∞–µ–º –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –±–æ—Ç–∞ (Singleton)
bot_manager = BotManager()

# –≠–∫—Å–ø–æ—Ä—Ç
__all__ = ['BotManager', 'bot_manager']

# –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
if __name__ == "__main__":
    # –≠—Ç–æ—Ç –±–ª–æ–∫ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –ø—Ä—è–º–æ–º –∑–∞–ø—É—Å–∫–µ —Ñ–∞–π–ª–∞
    # –ü–æ–ª–µ–∑–Ω–æ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
    print("ü§ñ BotManager module loaded successfully")
    print(f"üìä Manager instance: {bot_manager}")
    print(f"üîß Configuration loaded: {hasattr(config, 'BYBIT_API_KEY')}")